/*
 * Copyright 2017 Nancy Green
 * This file is part of AVIZE.
 *
 * AVIZE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AVIZE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AVIZE.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.uncg.save.argumentviewtree;

import static com.uncg.save.argumentviewtree.ArgumentNode.PADDING;
import static com.uncg.save.argumentviewtree.ArgumentNode.PREMISE_HEIGHT;
import com.uncg.save.controllers.ArgumentCertaintyPaneController;
import com.uncg.save.controllers.CQPaneController;
import com.uncg.save.controllers.ChainPaneController;
import com.uncg.save.controllers.ChainPropositionChoice;
import com.uncg.save.controllers.ChainTwoPropWarningPaneController;
import com.uncg.save.controllers.ConclusionPaneController;
import com.uncg.save.controllers.CounterArgumentPaneController;
import com.uncg.save.controllers.MultiArgChainPaneController;
import com.uncg.save.controllers.MultiArgConclusionPaneController;
import com.uncg.save.controllers.MultiArgSubConclusionPaneController;
import com.uncg.save.controllers.ConstructionAreaController;
import com.uncg.save.controllers.PremisePaneController;
import com.uncg.save.models.ArgumentModel;
import com.uncg.save.util.LayoutUtils;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.logging.Level;
import java.util.logging.Logger;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Modality;
import javafx.stage.Stage;
import static com.uncg.save.argumentviewtree.ArgumentNode.PREMISE_WIDTH;
import com.uncg.save.controllers.CQArgumentPaneController;
import com.uncg.save.controllers.CounterPropositionPaneController;
import com.uncg.save.models.CounterArgumentModel;
import com.uncg.save.models.PremiseModel;
import java.util.LinkedHashSet;
import java.util.Queue;
import java.util.Set;

/**
 * ArgumentViewTree class provides an entrance to an argument view tree via
 * root. It also defines methods used in the construction, deletion, and
 * alteration of argument view trees.
 *
 * TODO: this class needs major refactoring to remove repeated code and make the
 * class more focused
 */
public class ArgumentViewTree {

    // unique string id. Generated by getting string representation of
    // getHash() method of this tree object
    private String treeID;

    private ConclusionNode root;

    // collison matrices used to detect collision between view elements
    List<List<ArgumentNode>> paneMatrix;
    List<List<ArgumentNode>> nexusMatrix;

    // Pane that represents the constructionArea that this tree will be drawn on
    private final Pane canvas;
    private final ConstructionAreaController canvasControl;

    /**
     * Constructs new ArgumentViewTree and associates it with a specific pane
     * that will contain it. Starts with a null root.
     *
     * @param pane Pane
     */
    public ArgumentViewTree( Pane pane, ConstructionAreaController control )
    {
        canvas = pane;
        canvasControl = control;
        root = null;
        paneMatrix = new LinkedList<>();
        nexusMatrix = new LinkedList<>();
    }

    /*
     * Getters/setters
     */
    public ConclusionNode getRoot()
    {
        return root;
    }

    public String getTreeID()
    {
        return treeID;
    }

    public void setTreeID( String id )
    {
        treeID = id;
    }

    public List<List<ArgumentNode>> getPaneMatrix()
    {
        return this.paneMatrix;
    }

    public List<List<ArgumentNode>> getNexusMatrix()
    {
        return this.nexusMatrix;
    }

    /**
     * Adds a new root argument to a tree. This should be called when a new
     * argument is to be generated from a scheme.
     *
     * @param argument ArgumentModel. Backing model for the root argument
     * @param x        double. X coordinate value specifying where the tree will
     *                 be generated.
     * @param y        double. Y coordinate value specifying where the tree will
     *                 be generated.
     */
    public void addRootArgument( ArgumentModel argument, double x, double y )
    {
        try
        {
            Point2D localCoords = LayoutUtils.getLocalCoords( canvas, x, y );
            root = createConclusionView( argument, localCoords );
            canvas.getChildren().add( root.getView() );
            List<ArgumentNode> rootPaneList = new ArrayList<>();
            rootPaneList.add( root );
            paneMatrix.add( rootPaneList );

            ArgumentNode certaintyBox
                    = createArgumentCertaintyBox( argument.getConclusion(), root );
            root.addAsChild( certaintyBox );
            certaintyBox.setParent( root );
            canvas.getChildren().add( certaintyBox.getView() );

            ArgumentNode connector
                    = createConclusionConnector( root.getView() );
            root.addAsChild( connector );
            connector.setParent( root );
            canvas.getChildren().add( connector.getView() );

            ArgumentNode schemeLabel
                    = createSchemeLabel( argument, root.getView() );
            root.addAsChild( schemeLabel );
            schemeLabel.setParent( root );
            canvas.getChildren().add( schemeLabel.getView() );

            ArgumentNode nexus
                    = createNexus(
                            argument.getSchemeNumPremises(),
                            connector.getView()
                    );
            connector.addAsChild( nexus );
            nexus.setParent( connector );
            canvas.getChildren().add( nexus.getView() );
            List<ArgumentNode> rootNexusList = new ArrayList<>();
            rootNexusList.add( nexus );
            nexusMatrix.add( rootNexusList );

            int numPremises = argument.getSchemeNumPremises();
            List<ArgumentNode> premiseNodes = new ArrayList<>();
            for ( int i = 0; i < numPremises; i++ )
            {
                ArgumentNode premiseConnect
                        = createPremiseConnection( nexus.getView(), i );
                nexus.addAsChild( premiseConnect );
                premiseConnect.setParent( nexus );
                canvas.getChildren().add( premiseConnect.getView() );

                ArgumentNode premiseBox = createPremiseView(
                        argument,
                        premiseConnect.getView(),
                        i
                );
                ArgumentNode certaintyBoxP
                        = createArgumentCertaintyBox( argument, ( PremiseNode ) premiseBox );
                premiseBox.addAsChild( certaintyBoxP );
                certaintyBoxP.setParent( premiseBox );
                canvas.getChildren().add( certaintyBoxP.getView() );
                premiseConnect.addAsChild( premiseBox );
                premiseBox.setParent( premiseConnect );
                canvas.getChildren().add( premiseBox.getView() );

                premiseNodes.add( premiseBox );
            }
            paneMatrix.add( premiseNodes );
        } catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class.getName() ).log( Level.SEVERE, null, ex );
        }
    }

    /**
     * Creates a new conclusion pane to be drawn on the tree
     *
     * @param arg ArgumentModel. Backing model for argument
     * @param x   double. X coordinate value specifying where the tree will be
     *            generated.
     * @param y   double. Y coordinate value specifying where the tree will be
     *            generated.
     *
     * @return ArgumentNode to be added to tree structure
     *
     * @throws IOException in case of FXML loading failure
     */
    private ConclusionNode createConclusionView(
            ArgumentModel arg, Point2D localCoords ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/ConclusionPane.fxml" ) );
        Pane conclusionPane = loader.load();
        ConclusionPaneController conclusionControl
                = loader.<ConclusionPaneController>getController();
        conclusionControl.addConclusionArgumentModel( arg );
        conclusionControl.setArgumentViewTree( this );
        conclusionControl.setParentControl( canvasControl );
        Label lbl = createLabel();
        lbl.setText( arg.getSchemeConclusion() );
        conclusionControl.setSchemeLabel( lbl );
        LayoutUtils.setChildLayout( conclusionPane, localCoords );

        return new ConclusionNode( conclusionPane, conclusionControl );
    }

    private ArgumentNode createArgumentCertaintyBox(
            PremiseModel controllingModel, ConclusionNode parent ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader(
                getClass().getResource( "/fxml/ArgumentCertaintyPane.fxml" )
        );
        Pane certPane = loader.load();
        ArgumentCertaintyPaneController certControl
                = loader.<ArgumentCertaintyPaneController>getController();
        parent.getControl().setCertaintyController( certControl );

        canvas.layout();
        Bounds bounds = parent.getView().getBoundsInParent();
        Point2D targetCoords = new Point2D( bounds.getMaxX() - 15, bounds.getMaxY() );
        certControl.setControllingModel( controllingModel );
        return new ArgumentCertaintyNode( certPane, certControl, targetCoords );
    }

    private ArgumentNode createArgumentCertaintyBox(
            ArgumentModel argument, PremiseNode parent ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader(
                getClass().getResource( "/fxml/ArgumentCertaintyPane.fxml" )
        );
        Pane certPane = loader.load();
        ArgumentCertaintyPaneController certControl
                = loader.<ArgumentCertaintyPaneController>getController();
        parent.getControl().setCertaintyController( certControl );

        canvas.layout();
        Bounds bounds = parent.getView().getBoundsInParent();
        Point2D targetCoords = new Point2D( bounds.getMaxX() - 15, bounds.getMaxY() );
        certControl.setControllingModel( argument.getConclusion() );
        return new ArgumentCertaintyNode( certPane, certControl, targetCoords );
    }

    /**
     * Creates a new Node that connects the conclusion pane to the premise
     * structure. Its layout is determine in relation to the layout of its
     * parent view
     *
     * @param parentView Node. Parent conclusion pane of this connector
     *
     * @return ArgumentNode to be added to the tree structure
     */
    private ArgumentNode createConclusionConnector( Node parentView )
    {
        Point2D layout = getRelativeLayout( parentView );
        ConclusionConnectionNode connector
                = new ConclusionConnectionNode( layout );

        return connector;
    }

    private ArgumentNode createSchemeLabel(
            ArgumentModel argument, Node parentView )
    {
        Point2D layout = getRelativeLayout( parentView );
        ArgumentNode schemeLabel = new ArgumentSchemeLabel( argument, layout, this, canvas );

        return schemeLabel;
    }

    /**
     * Creates a "premise nexus" the horizontal line that graphically joins all
     * of the premises in an argument in the argument view tree
     *
     * @param arg        ArgumentModel. Backing model for the argument
     *                   associated with this part of the tree
     * @param parentView Node. Parent JavaFX node of this node.
     *
     * @return ArgumentNode to be added to the tree structure
     */
    private ArgumentNode createNexus( int numPremises, Node parentView )
    {
        Point2D layout = getRelativeLayout( parentView );
        PremiseNexusNode nexus
                = new PremiseNexusNode( numPremises, layout );

        return nexus;
    }

    /**
     * Creates the vertical lines that connect premise views to the premise
     * nexus. Their position is determined relative to their parent premise
     * nexus and are also offset according to which premise number they are\
     * associated with.
     *
     * @param parentView    Node. JavaFX parent of this view structure. Should
     *                      be a view contained in a PremiseNexus
     * @param premiseNumber int. Number representing the premise position.
     *
     * @return ArgumentNode meant to be added to the tree structure
     */
    private ArgumentNode createPremiseConnection(
            Node parentView, int premiseNumber )
    {
        Point2D layout = getRelativeLayout( parentView );
        Point2D adjustedLayout = new Point2D(
                layout.getX() - parentView.getBoundsInParent().getWidth() / 2,
                layout.getY()
        );
        PremiseConnectionNode premiseConnection
                = new PremiseConnectionNode( premiseNumber, adjustedLayout );

        return premiseConnection;
    }

    private ArgumentNode createMultiArgPremiseConnection(
            Node parentView, int premiseNumber )
    {
        Point2D layout = getRelativeLayout( parentView );
        Point2D adjustedLayout = new Point2D(
                layout.getX() - parentView.getBoundsInParent().getWidth() / 2,
                layout.getY()
        );
        MultiArgPremiseConnectionNode multiArgPremiseConnection
                = new MultiArgPremiseConnectionNode(
                        premiseNumber, adjustedLayout
                );

        return multiArgPremiseConnection;
    }

    /**
     * Creates a premise pane whose position is determined relative to its
     * parent PremiseConnectionNode.
     *
     * @param arg           ArgumentModel. Backing argument model this premise
     *                      is a part of
     * @param parentView    Node. JavaFX Node parent of this view structure.
     *                      Should be a view contained in a
     *                      PremiseConnectionNode.
     * @param premiseNumber int. Number representing the prosition of this
     *                      premise within its associated argument.
     *
     * @return ArgumnentMode meant to be added to the tree structure
     *
     * @throws IOException in case of FXML load failure
     */
    private ArgumentNode createPremiseView(
            ArgumentModel arg, Node parentView, int premiseNumber ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/PremisePane.fxml" ) );
        Pane premisePane = loader.load();
        PremisePaneController premiseControl
                = loader.<PremisePaneController>getController();
        premiseControl.setPosition( premiseNumber );
        premiseControl.setArgumentViewTree( this );
        premiseControl.setArgumentModel( arg );
        premiseControl.setParentControl( canvasControl );
        Label lbl = createLabel();
        lbl.setText( arg.getSchemePremise( premiseNumber ) );
        premiseControl.setSchemeLabel( lbl );
        Point2D layout = getRelativeLayout( parentView );
        Point2D adjustedLayout = new Point2D(
                ( int ) ( layout.getX() - PREMISE_WIDTH / 2 ),
                ( int ) layout.getY()
        );

        LayoutUtils.setChildLayout( premisePane, adjustedLayout );

        return new PremiseNode( premisePane, premiseControl );
    }

    /**
     * Creates a new pane and ArgumentNode for the conclusion to multiple
     * arguments that share the same conclusion. Uses the conclusion
     * proposition.
     *
     * @param parentNode        ArgumentNode parent of the created node
     * @param conclusionControl
     * @param premiseControl
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createMultiArgChainViewConclusion(
            ArgumentNode parentNode,
            ConclusionPaneController conclusionControl,
            PremisePaneController premiseControl )
            throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/MultiArgChainPane.fxml" ) );
        Pane chainPane = loader.load();
        MultiArgChainPaneController chainControl
                = loader.<MultiArgChainPaneController>getController();
        for ( ArgumentModel arg
                : conclusionControl.getConclusionArgumentModelList() )
        {
            chainControl.addConclusionArgumentModel( arg );
        }

        chainControl.addPremiseArgument( premiseControl.getArgument() );
        chainControl.setArgumentViewTree( this );
        chainControl.setParentControl( canvasControl );
        chainControl.setPosition( premiseControl.getPosition() );

        chainControl.setPropositionModel(
                conclusionControl
                        .getConclusionArgumentModel()
                        .getConclusion()
                        .getProposition()
        );

        Point2D layout = getRelativeLayout( parentNode.getView() );
        Point2D adjustedLayout = new Point2D(
                ( int ) ( layout.getX() - PREMISE_WIDTH / 2 ),
                ( int ) layout.getY()
        );

        LayoutUtils.setChildLayout( chainPane, adjustedLayout );
        return new ChainNode( chainPane, chainControl );
    }

    /**
     * Creates a new pane and ArgumentNode for the conclusion to multiple
     * arguments that share the same conclusion. Uses the premise proposition.
     *
     * @param parentNode
     * @param conclusionControl
     * @param premiseControl
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createMultiArgChainViewPremise(
            ArgumentNode parentNode,
            ConclusionPaneController conclusionControl,
            PremisePaneController premiseControl )
            throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/MultiArgChainPane.fxml" ) );
        Pane chainPane = loader.load();
        MultiArgChainPaneController chainControl
                = loader.<MultiArgChainPaneController>getController();

        for ( ArgumentModel arg
                : conclusionControl.getConclusionArgumentModelList() )
        {
            chainControl.addConclusionArgumentModel( arg );
        }

        chainControl.addPremiseArgument( premiseControl.getArgument() );
        chainControl.setArgumentViewTree( this );
        chainControl.setParentControl( canvasControl );

        chainControl.setPosition( premiseControl.getPosition() );

        chainControl.setPropositionModel(
                premiseControl.getProposition()
        );

        Point2D layout = getRelativeLayout( parentNode.getView() );
        Point2D adjustedLayout = new Point2D(
                ( int ) ( layout.getX() - PREMISE_WIDTH / 2 ),
                ( int ) layout.getY()
        );

        LayoutUtils.setChildLayout( chainPane, adjustedLayout );
        return new ChainNode( chainPane, chainControl );
    }

    /**
     * Creates a ChainPane as part of a merger procedure, inheriting the
     * properties and fields of the conclusion being merged in to this tree
     *
     * @param parentNode        ArgumentNode parent of the point of merger
     * @param conclusionControl ConclusionPaneController controller of the
     *                          conclusion being merged in
     * @param premiseControl    PremisePaneController controller of the premise
     *                          that is being merged into
     *
     * @return ArgumentNode the created Chain Pane
     *
     * @throws IOException
     */
    private ArgumentNode createChainViewConclusion(
            ArgumentNode parentNode,
            ConclusionPaneController conclusionControl,
            PremisePaneController premiseControl )
            throws IOException
    {
        ChainPaneController chainControl = generateChainNode();

        chainControl.addConclusionArgumentModel(
                conclusionControl.getConclusionArgumentModel()
        );
        chainControl.addPremiseArgument( premiseControl.getArgument() );
        chainControl.setArgumentViewTree( this );
        chainControl.setParentControl( canvasControl );
        chainControl.setCertaintyController(
                conclusionControl.getCertaintyController()
        );
        chainControl.setPosition( premiseControl.getPosition() );
        chainControl.setPropositionModel(
                conclusionControl.getConclusionArgumentModel().getConclusion().getProposition()
        );
        chainControl.checkHasProp();

        Point2D layout = getRelativeLayout( parentNode.getView() );
        Point2D adjustedLayout = new Point2D(
                ( int ) ( layout.getX() - PREMISE_WIDTH / 2 ),
                ( int ) layout.getY()
        );

        LayoutUtils.setChildLayout( chainControl.getMainPane(), adjustedLayout );
        return new ChainNode( chainControl.getMainPane(), chainControl );
    }

    /**
     * Creates a ChainPane as part of a merger procedure, inheriting the
     * properties and fields of the premise that is being merged into
     *
     * @param parentNode        ArgumentNode parent of the point of merger
     * @param conclusionControl ConclusionPaneController controller of the
     *                          conclusion being merged in
     * @param premiseControl    PremisePaneController controller of the premise
     *                          that is being merged into
     *
     * @return ArgumentNode the created Chain Pane
     *
     * @throws IOException
     */
    private ArgumentNode createChainViewPremise(
            ArgumentNode parentNode,
            ConclusionPaneController conclusionControl,
            PremisePaneController premiseControl )
            throws IOException
    {
        ChainPaneController chainControl = generateChainNode();

        chainControl.setArgumentViewTree( this );
        chainControl.addConclusionArgumentModel(
                conclusionControl.getConclusionArgumentModel()
        );
        chainControl.addPremiseArgument( premiseControl.getArgument() );
        chainControl.setParentControl( canvasControl );
        chainControl.setCertaintyController(
                premiseControl.getCertaintyController()
        );
        chainControl.setPosition( premiseControl.getPosition() );
        chainControl.setPropositionModel(
                premiseControl.getProposition()
        );
        chainControl.checkHasProp();

        Point2D layout = getRelativeLayout( parentNode.getView() );
        Point2D adjustedLayout = new Point2D(
                ( int ) ( layout.getX() - PREMISE_WIDTH / 2 ),
                ( int ) layout.getY()
        );

        LayoutUtils.setChildLayout( chainControl.getMainPane(), adjustedLayout );
        return new ChainNode( chainControl.getMainPane(), chainControl );
    }

    /**
     * Creates a Chain Pane and its associated node
     *
     * @return ChainPaneController the controller of the chain pane
     *
     * @throws IOException
     */
    private ChainPaneController generateChainNode() throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/ChainPane.fxml" ) );
        Pane chainPane = loader.load();
        ChainPaneController chainControl
                = loader.<ChainPaneController>getController();
        return chainControl;
    }

    /**
     * Creates a new conclusion for multiple arguments that share the same
     * conclusion when a multi-arg structure is being detached
     *
     * @param multiChainNode
     * @param multiChainControl
     *
     * @return
     *
     * @throws IOException
     */
    private ConclusionNode createNewMultiArgConclusion(
            ArgumentNode multiChainNode,
            MultiArgChainPaneController multiChainControl )
            throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/MultiArgConclusionPane.fxml" ) );
        Pane multiArgPane = loader.load();
        MultiArgConclusionPaneController multiArgControl
                = loader.<MultiArgConclusionPaneController>getController();

        for ( ArgumentModel arg
                : multiChainControl.getConclusionArgumentModelList() )
        {
            multiArgControl.addConclusionArgumentModel( arg );
        }
        multiArgControl.setParentControl( canvasControl );

        if ( multiChainControl.getProposition() != null )
        {
            multiArgControl.setPropositionModel(
                    multiChainControl.getProposition()
            );
        }

        Point2D adjustedLayout = new Point2D(
                ( int ) multiChainNode.getView().getBoundsInParent().getMinX(),
                ( int ) multiChainNode.getView().getBoundsInParent().getMinY()
        );

        LayoutUtils.setChildLayout( multiArgPane, adjustedLayout );
        return new ConclusionNode( multiArgPane, multiArgControl );
    }

    /**
     * Method creates the circular CQ icon
     *
     * @param parentNode ArgumentNode parent of the icon
     *
     * @return CQIcon ArgumentNode
     *
     * @throws IOException
     */
    private CQIcon createCQIcon( ArgumentNode parentNode ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/CriticalIconFXML.fxml" ) );
        Pane cqIcon = loader.load();

        Point2D targetCoords = new Point2D(
                parentNode.getView().getBoundsInParent().getMinX() - 100,
                parentNode.getView().getBoundsInParent().getMinY() - 50
        );
        LayoutUtils.setChildLayout( cqIcon, targetCoords );
        return new CQIcon( cqIcon );
    }

    /**
     * Creates a CQPane to contain an answer to a counter argument
     *
     * @param arg       ArgumentModel the response to the CQ
     * @param parentArg ArgumentModel that poses the CQ
     * @param parent    ArgumentNode parent node in the tree structure
     *
     * @return ArgumentNode the ArgumentNode
     *
     * @throws IOException
     */
    private ArgumentNode createCQView(
            ArgumentModel arg,
            ArgumentModel parentArg,
            ArgumentNode parent
    ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/CQPane.fxml" ) );
        Pane cqPane = loader.load();
        CQPaneController cqControl
                = loader.<CQPaneController>getController();
        cqControl.setArgumentViewTree( this );
        cqControl.setArgumentModel( arg );
        cqControl.setParentArgument( parentArg );
        cqControl.setParentControl( canvasControl );
        cqControl.setConnector( parent );
        Point2D layout = getRelativeLayout( parent.getView() );
        Point2D adjustedLayout
                = new Point2D(
                        ( int ) layout.getX() + parent.getWidth() - 163,
                        ( int ) layout.getY()
                );
        LayoutUtils.setChildLayout( cqPane, adjustedLayout );
        return new CQNode( cqPane, cqControl );
    }

    private ArgumentNode createCQConnection(
            ArgumentModel arg,
            ArgumentNode parentNode )
    {
        ArgumentNode targetNexus = findNextNexus( parentNode );
        Point2D parentLayout = getRelativeLayout( parentNode.getView() );
        Point2D nexusLayout = getRelativeLayout( targetNexus.getView() );
        Point2D adjustedLayout = new Point2D(
                parentLayout.getX(),
                nexusLayout.getY() - 60
        );
        CQConnectionNode cqConnection
                = new CQConnectionNode( adjustedLayout );

        return cqConnection;
    }

    /**
     * Method creates an pane using values from the conclusion of the merge
     *
     * @param parentNode
     * @param conclusionControl
     * @param cqControl
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createCQArgPaneConclusion(
            ArgumentNode parentNode,
            ConclusionPaneController conclusionControl,
            CQPaneController cqControl
    ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/CQArgumentPane.fxml" ) );
        Pane cqArgPane = loader.load();
        CQArgumentPaneController cqArgControl
                = loader.<CQArgumentPaneController>getController();
        cqArgControl.setArgumentModel(
                conclusionControl.getConclusionArgumentModel()
        );
        cqArgControl.setParentArgument( cqControl.getParentArgument() );
        cqArgControl.setArgumentViewTree( this );
        cqArgControl.setParentControl( canvasControl );
        cqArgControl.setCertaintyController(
                conclusionControl.getCertaintyController()
        );
        if ( conclusionControl.getConclusionArgumentModel().getConclusion() != null )
        {
            System.out.println( "setting prop model" );
            System.out.println( conclusionControl.getConclusionArgumentModel().getConclusion().getProposition() );
            cqArgControl.setPropositionModel(
                    conclusionControl.getConclusionArgumentModel().getConclusion().getProposition()
            );
        }
        Point2D layout = getRelativeLayout( parentNode.getView() );
        Point2D adjustedLayout
                = new Point2D(
                        ( int ) layout.getX()
                        + cqControl.getConnector().getWidth() - 163,
                        ( int ) layout.getY()
                );
        LayoutUtils.setChildLayout( cqArgPane, adjustedLayout );
        return new CQArgumentNode( cqArgPane, cqArgControl );
    }

    /**
     * Creates a CQ pane with the values from the premise side of the merge
     *
     * @param parentNode
     * @param conclusionControl
     * @param cqControl
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createCQArgPanePremise(
            ArgumentNode parentNode,
            ConclusionPaneController conclusionControl,
            CQPaneController cqControl
    ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/CQArgumentPane.fxml" ) );
        Pane cqArgPane = loader.load();
        CQArgumentPaneController cqArgControl
                = loader.<CQArgumentPaneController>getController();
        cqArgControl.setArgumentModel(
                conclusionControl.getConclusionArgumentModel()
        );
        cqArgControl.setParentArgument( cqControl.getParentArgument() );
        cqArgControl.setArgumentViewTree( this );
        cqArgControl.setParentControl( canvasControl );
        cqArgControl.setCertaintyController(
                cqControl.getCertaintyController()
        );
        cqArgControl.setPropositionModel(
                cqControl.getProposition()
        );

        Point2D layout = getRelativeLayout( parentNode.getView() );
        Point2D adjustedLayout = new Point2D( ( int ) layout.getX() + cqControl.getConnector().getWidth() - 163, ( int ) layout.getY() );

        LayoutUtils.setChildLayout( cqArgPane, adjustedLayout );

        return new CQArgumentNode( cqArgPane, cqArgControl );
    }

    /**
     * Creates the shield Icon for counter arguement structure
     *
     * @param parent ArgumentNode parent of the icon
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createCounterIcon( ArgumentNode parent )
            throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/CounterShieldFXML.fxml" ) );
        Pane counterIcon = loader.load();

        Point2D targetCoords = new Point2D(
                parent.getView().getBoundsInParent().getMaxX(),
                parent.getView().getBoundsInParent().getMinY() - 73
        );
        LayoutUtils.setChildLayout( counterIcon, targetCoords );
        return new CounterIcon( counterIcon );
    }

    /**
     * Creates a counter proposition view. Counter proposition views are counter
     * arguments that do not have a proper argument attached to them
     *
     * @param parentModelList
     * @param counterArg
     * @param parent
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createCounterPropositionView(
            List<PremiseModel> parentModelList,
            CounterArgumentModel counterArg,
            ArgumentNode parent ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/CounterPropositionPane.fxml" ) );
        Pane counterPane = loader.load();
        CounterPropositionPaneController counterControl
                = loader.<CounterPropositionPaneController>getController();
        counterControl.setArgumentViewTree( this );
        counterControl.setArgumentModel( counterArg );
        counterControl.setParentModelList( parentModelList );
        counterControl.setParentControl( canvasControl );
        Point2D layout = getRelativeLayout( parent.getView() );

        Point2D adjustedLayout;
        adjustedLayout
                = new Point2D(
                        ( int ) layout.getX() - ( PREMISE_WIDTH / 2 ),
                        ( int ) layout.getY()
                );

        LayoutUtils.setChildLayout( counterPane, adjustedLayout );
        return new CounterPropositionNode( counterPane, counterControl );
    }

    /**
     * Creates the connector between an argument and its counter arguments
     *
     * @param parentView
     *
     * @return
     */
    private ArgumentNode createCounterArgumentConnection( Node parentView )
    {
        Point2D adjustedLayout;
        adjustedLayout = new Point2D(
                parentView.getBoundsInParent().getMinX(),
                parentView.getBoundsInParent().getMinY()
        );

        CounterArgumentConnectionNode counterConnection
                = new CounterArgumentConnectionNode( adjustedLayout );

        return counterConnection;
    }

    /**
     * Creates a counter argument pane using the values of the conclusion side
     * of a merge
     *
     * @param parentNode
     * @param conclusionControl
     * @param counterControl
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createCounterArgumentViewConclusion(
            ArgumentNode parentNode,
            ConclusionPaneController conclusionControl,
            CounterPropositionPaneController counterControl )
            throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/CounterArgumentPane.fxml" ) );
        Pane counterArgumentPane = loader.load();
        CounterArgumentPaneController counterArgumentControl
                = loader.<CounterArgumentPaneController>getController();

        /*
         * remove the proposition counter argument from the parent argument's
         * counter arg list, replace it with the new merged conclusion's
         * argument
         */
        // get variable's set up for readability
        List<PremiseModel> parentModelList
                = counterControl.getParentModelList();
        List<List<CounterArgumentModel>> parentCounterArgLists
                = new ArrayList<>();

        for ( PremiseModel model : parentModelList )
        {
            parentCounterArgLists.add( model.getCounterArgumentList() );
        }

        ArgumentModel propCounterArg = counterControl.getArgument();
        ArgumentModel conclusionArgument
                = conclusionControl.getConclusionArgumentModel();
        CounterArgumentModel newCounterArgument
                = new CounterArgumentModel( conclusionArgument );

        for ( List<CounterArgumentModel> counterArgList
                : parentCounterArgLists )
        {
            int indexOfPropCounter = counterArgList.indexOf( propCounterArg );

            // the actual swap
            counterArgList.remove( propCounterArg );
            counterArgList.add( indexOfPropCounter, newCounterArgument );
        }

        /*
         * assign the fields for the created counter argument pane
         */
        counterArgumentControl.setArgumentModel( newCounterArgument );
        counterArgumentControl.setParentModelList( parentModelList );
        counterArgumentControl.setParentControl( canvasControl );
        counterArgumentControl.addProposition(
                conclusionControl.getProposition()
        );
        counterArgumentControl.setArgumentViewTree( this );
        counterArgumentControl.setCertaintyController(
                conclusionControl.getCertaintyController()
        );
        counterArgumentControl.setPosition( counterControl.getPosition() );

        Point2D layout = getRelativeLayout( parentNode.getView() );
        Point2D adjustedLayout = new Point2D(
                ( int ) ( layout.getX() - PREMISE_WIDTH / 2 ),
                ( int ) layout.getY()
        );
        LayoutUtils.setChildLayout( counterArgumentPane, adjustedLayout );
        return new CounterArgumentNode( counterArgumentPane, counterArgumentControl );
    }

    /**
     * Creates a counter argument pane using the values from the premise side of
     * a merge
     *
     * @param parentNode
     * @param conclusionControl
     * @param counterControl
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createCounterArgumentViewPremise(
            ArgumentNode parentNode,
            ConclusionPaneController conclusionControl,
            CounterPropositionPaneController counterControl )
            throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/CounterArgumentPane.fxml" ) );
        Pane counterArgumentPane = loader.load();
        CounterArgumentPaneController counterArgumentControl
                = loader.<CounterArgumentPaneController>getController();

        /*
         * remove the proposition counter argument from the parent argument's
         * counter arg list, replace it with the new merged conclusion's
         * argument
         */
        // get variable's set up for readability
        List<PremiseModel> parentModelList
                = counterControl.getParentModelList();
        List<List<CounterArgumentModel>> parentCounterArgLists
                = new ArrayList<>();

        for ( PremiseModel model : parentModelList )
        {
            parentCounterArgLists.add( model.getCounterArgumentList() );

        }

        ArgumentModel propCounterArg = counterControl.getArgument();

        ArgumentModel conclusionArgument
                = conclusionControl.getConclusionArgumentModel();
        CounterArgumentModel newCounterArgument
                = new CounterArgumentModel( conclusionArgument );

        for ( List<CounterArgumentModel> counterArgList
                : parentCounterArgLists )
        {
            int indexOfPropCounter = counterArgList.indexOf( propCounterArg );
            // the actual swap
            counterArgList.remove( propCounterArg );
            counterArgList.add( indexOfPropCounter, newCounterArgument );
        }
        counterArgumentControl.setArgumentModel( newCounterArgument );
        counterArgumentControl.setParentModelList( parentModelList );
        counterArgumentControl.setParentControl( canvasControl );
        counterArgumentControl.addProposition(
                counterControl.getProposition()
        );
        counterArgumentControl.setArgumentViewTree( this );

        counterArgumentControl.setCertaintyController(
                counterControl.getCertaintyController()
        );
        counterArgumentControl.setPosition( counterControl.getPosition() );

        Point2D layout = getRelativeLayout( parentNode.getView() );
        Point2D adjustedLayout = new Point2D(
                ( int ) ( layout.getX() - PREMISE_WIDTH / 2 ),
                ( int ) layout.getY()
        );
        LayoutUtils.setChildLayout( counterArgumentPane, adjustedLayout );
        return new CounterArgumentNode(
                counterArgumentPane,
                counterArgumentControl
        );
    }

    /**
     * Creates a view for an individual conclusion in a multiple-arguments
     * sharing the same conclusion structure
     *
     * @param arg
     * @param parentView
     * @param certaintyControl
     * @param pos
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createMultiArgSubView(
            ArgumentModel arg,
            Node parentView,
            ArgumentCertaintyPaneController certaintyControl,
            int pos
    ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/MultiArgSubConclusionPane.fxml" ) );
        Pane premisePane = loader.load();
        MultiArgSubConclusionPaneController subConControl
                = loader.<MultiArgSubConclusionPaneController>getController();
        subConControl.setArgumentViewTree( this );
        subConControl.setArgument( arg );
        subConControl.setParentControl( canvasControl );
        subConControl.setCertaintyControl( certaintyControl );

        Point2D layout = getRelativeLayout( parentView );
        Point2D adjustedLayout = new Point2D(
                ( int ) ( layout.getX() - ( 40 / 2 ) ),
                ( int ) layout.getY()
        );

        LayoutUtils.setChildLayout( premisePane, adjustedLayout );

        return new MultiArgSubNode( premisePane, subConControl );
    }

    /**
     * Creates a model for multiple arguments sharing the same conclusion
     *
     * @param parentView
     *
     * @return
     */
    private ArgumentNode createMultiArgLabel( Node parentView )
    {
        Point2D layout = getRelativeLayout( parentView );
        ArgumentNode label = new MultipleArgLabel( layout, this, canvas );

        return label;
    }

    /**
     * Creates a pane for the conclusion of multiple arguments sharing the same
     * conclusion with values taken from the conclusion side of a merge
     *
     * @param mainConNode
     * @param mainConControl
     * @param mergeConControl
     *
     * @return
     *
     * @throws IOException
     */
    private ConclusionNode createNewMultiArgConclusion(
            ArgumentNode mainConNode,
            ConclusionPaneController mainConControl,
            ConclusionPaneController mergeConControl )
            throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/MultiArgConclusionPane.fxml" ) );
        Pane multiArgPane = loader.load();
        MultiArgConclusionPaneController multiArgControl
                = loader.<MultiArgConclusionPaneController>getController();

        multiArgControl.setArgumentViewTree( this );
        multiArgControl.addConclusionArgumentModel( mainConControl.getConclusionArgumentModel() );
        multiArgControl.addConclusionArgumentModel( mergeConControl.getConclusionArgumentModel() );
        multiArgControl.setParentControl( canvasControl );

        multiArgControl.setPropositionModel(
                mainConControl.getProposition()
        );
        Point2D adjustedLayout = new Point2D(
                ( int ) mainConNode.getView().getBoundsInParent().getMinX(),
                ( int ) mainConNode.getView().getBoundsInParent().getMinY()
        );

        LayoutUtils.setChildLayout( multiArgPane, adjustedLayout );
        return new ConclusionNode( multiArgPane, multiArgControl );
    }

    private ChainNode createMultiArgChainView(
            ConclusionPaneController conclusionControl,
            ChainPaneController chainControl )
            throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass()
                .getResource( "/fxml/MultiArgChainPane.fxml" ) );
        Pane chainPane = loader.load();
        MultiArgChainPaneController multiChainControl
                = loader.<MultiArgChainPaneController>getController();
        if ( chainControl.getCQFlag() )
        {
            multiChainControl.setCQFlag();
            multiChainControl.setConnector( chainControl.getConnector() );
        }
        if ( chainControl.getCounterFlag() )
        {
            multiChainControl.setCounterFlag();
            multiChainControl.setConnector( chainControl.getConnector() );
        }
        for ( ArgumentModel arg
                : conclusionControl.getConclusionArgumentModelList() )
        {
            multiChainControl.addConclusionArgumentModel( arg );
        }

        for ( ArgumentModel arg
                : chainControl.getConclusionArgumentModelList() )
        {
            multiChainControl.addConclusionArgumentModel( arg );
        }
        multiChainControl.addPremiseArgument( chainControl.getPremiseArgument() );
        multiChainControl.setArgumentViewTree( this );
        multiChainControl.setParentControl( canvasControl );

        multiChainControl.setPosition( chainControl.getPosition() );

        multiChainControl.setPropositionModel(
                chainControl.getProposition()
        );

        multiChainControl.getMainPane().setLayoutX( chainControl.getMainPane().getLayoutX() );
        multiChainControl.getMainPane().setLayoutY( chainControl.getMainPane().getLayoutY() );
        return new ChainNode( chainPane, multiChainControl );
    }

    /**
     * Opens a dialogue window for the user to pick which proposition will be
     * carried over when chaining arguments
     *
     * @return ChainPropositionChoice which is an enum value specifying the
     *         users selection
     *
     * @throws IOException
     */
    private ChainPropositionChoice showPropositionChoiceDialogue() throws IOException
    {
        FXMLLoader loader
                = new FXMLLoader(
                        getClass().getResource(
                                "/fxml/ChainTwoPropWarningPane.fxml"
                        )
                );
        Parent propChoiceBox = loader.load();
        ChainTwoPropWarningPaneController propChoiceControl
                = loader
                        .<ChainTwoPropWarningPaneController>getController();
        Scene scene = new Scene( propChoiceBox );
        Stage stage = new Stage();
        stage.setTitle( "Choose proposition" );
        stage.setScene( scene );
        stage.initModality( Modality.APPLICATION_MODAL );
        stage.initOwner( canvas.getScene().getWindow() );
        stage.showAndWait();
        return propChoiceControl.getUserPropositionChoice();
    }

    /**
     * Calculates the appropriate layout of a Node relative to its parent. This
     * method should return a point that is the the bottom center of a parent
     * view.
     *
     * @param parentView Node. Parent JavaFX Node meant to be used as a
     *                   reference for calculating the desired Point coordinates
     *
     * @return Point2D coordinates detailing a point at the bottom center of the
     *         specified parent Node
     */
    private Point2D getRelativeLayout( Node parentView )
    {
        canvas.layout();
        Bounds parentBounds = parentView.getBoundsInParent();
        double parentHeight = parentBounds.getHeight();
        double parentWidth = parentBounds.getWidth();

        double targetX = parentBounds.getMinX() + parentWidth / 2;
        double targetY = parentBounds.getMinY() + parentHeight;
        Point2D localCoords = new Point2D( targetX, targetY );
        return localCoords;
    }

    /**
     * Calculates the translation necessary for relocating a node to the
     * specified coordinates. Calls a helper method that recursively iterates
     * through the tree to translate all child nodes
     *
     * @param x double. Destination X coordinate
     * @param y double. Destination Y coordinate
     */
    public void translateTree( double x, double y )
    {
        double transX = x - root.getView().getLayoutX();
        double transY = y - root.getView().getLayoutY();
        translateNode( root, transX, transY );
    }

    /**
     * Helper method that translates a node by the specified X and Y amounts,
     * then recursively processes all child ArgumentNodes
     *
     * @param node ArgumentNode to be translated
     * @param x    double. Translation amount on X plane
     * @param y    double. Translation amount on Y plane
     */
    public void translateNode( ArgumentNode node, double x, double y )
    {
        node.getView().setLayoutX( node.getView().getLayoutX() + x );
        node.getView().setLayoutY( node.getView().getLayoutY() + y );
        node.moveComment( x, y );
        for ( ArgumentNode child : node.getChildren() )
        {
            translateNode( child, x, y );
        }
    }

    /**
     * Method for attaching a subtree to an existing tree.
     *
     * @param newNode   ArgumentNode point of connection between the two trees
     * @param oldNode   ArgumentNode that is replaced by newNode
     * @param parent    ArgumentNode parent of oldNode
     * @param subTree   ArgumentViewTree that will be attached
     * @param subTreeID String ID of subtree
     */
    private void attachNewSubTree(
            ArgumentNode newNode,
            ArgumentNode oldNode,
            ArgumentNode parent,
            ArgumentViewTree subTree,
            String subTreeID
    )
    {
        newNode.setParent( parent );
        rearrangeChildren(
                parent,
                oldNode,
                newNode,
                subTree
        );
        updateNexusMatrix( newNode, subTree );
        updatePaneMatrix( oldNode, newNode, subTree );
        canvasControl.removeArgumentTree( subTreeID );
    }

    /**
     * Method to delete all comments in an argument view tree
     */
    public void deleteCommentPanes()
    {
        root.deleteCommentPane();
        deleteCommentPane( root );
    }

    /**
     * Recursive helper method to delete all comments in a tree
     *
     * @param node
     */
    public void deleteCommentPane( ArgumentNode node )
    {
        node.deleteCommentPane();
        for ( ArgumentNode child : node.getChildren() )
        {
            deleteCommentPane( child );
        }
    }

    /**
     * Recursively goes through an ArgumentViewTree starting at the specified
     * ArgumentNode and sets its ArgumentViewTree reference to this tree
     *
     * @param node ArgumentNode
     */
    private void changeArgTree( ArgumentNode node )
    {
        node.setArgTree( this );
        for ( ArgumentNode child : node.getChildren() )
        {
            changeArgTree( child );
        }
    }

    private ArgumentNode searchForNode(
            ArgumentNode node, Pane target )
    {
        if ( node.getView().equals( target ) )
        {
            return node;
        }
        ArgumentNode result = null;
        for ( int i = 0; result == null && i < node.getChildren().size(); i++ )
        {
            result = searchForNode(
                    node.getChildren().get( i ), target
            );
        }
        return result;
    }

    /**
     * Reassigns children/parent relations when merging argument structures.
     *
     * @param targetParent ArgumentNode parent of the target node
     * @param target       ArgumentNode point of merger, will be replaced by a
     *                     new type of node that will link the two argument
     *                     structures
     * @param chainNode    ArgumentNode new argument node meant to link the two
     *                     argument structures
     * @param mergedTree   ArgumentViewTree being merged into this one
     */
    private void rearrangeChildren(
            ArgumentNode targetParent,
            ArgumentNode target,
            ArgumentNode chainNode,
            ArgumentViewTree mergedTree )
    {
        targetParent.removeChild( target );
        targetParent.addAsChild( chainNode );

        ListIterator<ArgumentNode> targetChildren
                = target.getChildren().listIterator();
        while ( targetChildren.hasNext() )
        {
            ArgumentNode child = targetChildren.next();
            chainNode.addAsChild( child );
            child.setParent( chainNode );
            targetChildren.remove();
        }

        canvas.getChildren().add( chainNode.getView() );
        canvas.getChildren().remove( target.getView() );

        mergedTree.translateTree(
                chainNode.getView().getLayoutX(),
                chainNode.getView().getLayoutY()
        );

        ArgumentNode mergedTreeRoot = mergedTree.getRoot();
        ListIterator<ArgumentNode> oldTreeChildren
                = mergedTreeRoot.getChildren().listIterator();
        while ( oldTreeChildren.hasNext() )
        {
            ArgumentNode child = oldTreeChildren.next();
            chainNode.addAsChild( child );
            child.setParent( chainNode );
            changeArgTree( child );
            oldTreeChildren.remove();
        }
        canvas.getChildren().remove( mergedTreeRoot.getView() );
    }

    /**
     * Check if this tree contains the specified node
     *
     * @param node ArgumentNode being searched for
     *
     * @return boolean
     */
    private boolean containsNode( ArgumentNode node )
    {
        return containsNode( root, node );
    }

    /**
     * Recursive helper method to traverse the tree searching for target
     * ArgumentNode
     *
     * @param current ArgumentNode being inspected
     * @param target  ArgumentNode being searched for
     *
     * @return boolean
     */
    private boolean containsNode( ArgumentNode current, ArgumentNode target )
    {
        if ( current.equals( target ) )
        {
            return true;
        }

        boolean targetFound = false;
        for ( int i = 0; !targetFound && i < current.getChildren().size(); i++ )
        {
            targetFound = containsNode( current.getChildren().get( i ), target );
        }
        return targetFound;
    }

    /**
     * sets the root of this argument view tree
     *
     * @param root
     */
    private void setRoot( ConclusionNode root )
    {
        this.root = root;
    }

    /**
     * Method deletes this argument structure and erases it from the gui
     */
    public void deleteArgument()
    {
        deleteCommentPanes();
        eraseTree( root );
        canvasControl.removeArgumentTree( treeID );
    }

    /**
     * Recursively erases all elements of this tree from the construction area
     *
     * @param node ArgumentNode currently being erased
     */
    private void eraseTree( ArgumentNode node )
    {
        canvas.getChildren().remove( node.getView() );
        ListIterator<ArgumentNode> it = node.getChildren().listIterator();
        while ( it.hasNext() )
        {
            eraseTree( it.next() );
        }
    }

    /**
     * Creates a new label
     *
     * @return
     */
    private Label createLabel()
    {
        Label lbl = new Label();
        lbl.setWrapText( true );
        lbl.setMaxWidth( 305 );
        lbl.setTextFill( Color.WHITE );
        lbl.setLayoutX( 10 );
        lbl.setLayoutY( 5 );
        lbl.setFont( new Font( "System Regular", 18 ) );
        return lbl;
    }

    // Methods for handleing tree mergers such as adding sub arguments
    //--------------------------------------------------------------------------
    /**
     * Method for chaining arguments. Merges arguments by making one a
     * sub-argument of the other
     *
     * @param futureChildID  String ID of the tree that will become a
     *                       sub-arguments
     * @param premiseControl point of merger in the "main" tree
     */
    public void mergeTree( String futureChildID,
            PremisePaneController premiseControl )
    {
        ArgumentViewTree mergedTree = canvasControl.getArgTree( futureChildID );
        mergedTree.deleteCommentPanes();
        ArgumentNode target
                = searchForNode( root, premiseControl.getMainPane() );
        ArgumentNode targetParent = target.getParent();
        ArgumentNode chainNode = null;
        deleteCommentPane( target );
        try
        {
            if ( premiseControl.getProposition() != null
                    || mergedTree.getRoot()
                            .getControl().getProposition() != null )
            {
                if ( premiseControl.getProposition() != null
                        && mergedTree.getRoot()
                                .getControl().getProposition() != null )
                {
                    ChainPropositionChoice userChoice
                            = showPropositionChoiceDialogue();
                    if ( userChoice == ChainPropositionChoice.CONCLUSION )
                    {
                        if ( mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController )
                        {
                            chainNode = createMultiArgChainViewConclusion(
                                    targetParent,
                                    mergedTree.getRoot().getControl(),
                                    premiseControl
                            );
                        } else
                        {
                            chainNode = createChainViewConclusion(
                                    targetParent,
                                    mergedTree.getRoot().getControl(),
                                    premiseControl
                            );
                        }
                    } else if ( userChoice == ChainPropositionChoice.PREMISE )
                    {
                        if ( mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController )
                        {
                            chainNode = createMultiArgChainViewPremise(
                                    targetParent,
                                    mergedTree.getRoot().getControl(),
                                    premiseControl
                            );
                        } else
                        {
                            chainNode = createChainViewPremise(
                                    targetParent,
                                    mergedTree.getRoot().getControl(),
                                    premiseControl
                            );
                        }
                    } else
                    {
                        System.out.println( "canceled with no merge" );;
                    }
                } else if ( premiseControl.getProposition() == null
                        && mergedTree.getRoot()
                                .getControl().getProposition() != null )
                {
                    if ( mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController )
                    {
                        chainNode = createMultiArgChainViewConclusion(
                                targetParent,
                                mergedTree.getRoot().getControl(),
                                premiseControl
                        );
                    } else
                    {
                        chainNode = createChainViewConclusion(
                                targetParent,
                                mergedTree.getRoot().getControl(),
                                premiseControl
                        );
                    }
                } else if ( premiseControl.getProposition() != null
                        && mergedTree.getRoot()
                                .getControl().getProposition() == null )
                {
                    if ( mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController )
                    {
                        chainNode = createMultiArgChainViewPremise(
                                targetParent,
                                mergedTree.getRoot().getControl(),
                                premiseControl
                        );
                    } else
                    {
                        chainNode = createChainViewPremise(
                                targetParent,
                                mergedTree.getRoot().getControl(),
                                premiseControl
                        );
                    }
                }
                attachNewSubTree(
                        chainNode,
                        target,
                        targetParent,
                        mergedTree,
                        futureChildID
                );
                canvasControl.removeArgumentTree( futureChildID );
                collisionAdjustment();
                canvasControl.constructionAreaSizeCheck();
            }
        } catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class
                    .getName() ).log( Level.SEVERE, null, ex );
        }
    }

    /**
     * Method for chaining an argument to a counter proposition pane
     *
     * @param futureChildID
     * @param counterControl
     */
    public void mergeTree( String futureChildID,
            CounterPropositionPaneController counterControl )
    {
        ArgumentNode target
                = searchForNode( root, counterControl.getMainPane() );
        ArgumentNode targetParent = target.getParent();
        ArgumentViewTree mergedTree = canvasControl.getArgTree( futureChildID );
        ArgumentNode counterArgumentNode = null;
        mergedTree.deleteCommentPanes();
        deleteCommentPane( target );
        try
        {
            if ( counterControl.getProposition() != null
                    || mergedTree.getRoot()
                            .getControl().getProposition() != null )
            {
                if ( counterControl.getProposition() != null
                        && mergedTree.getRoot()
                                .getControl().getProposition() != null )
                {
                    ChainPropositionChoice userChoice
                            = showPropositionChoiceDialogue();
                    if ( userChoice == ChainPropositionChoice.CONCLUSION )
                    {
                        counterArgumentNode = createCounterArgumentViewConclusion(
                                targetParent,
                                mergedTree.getRoot().getControl(),
                                counterControl
                        );
                    } else if ( userChoice == ChainPropositionChoice.PREMISE )
                    {
                        counterArgumentNode = createCounterArgumentViewPremise(
                                targetParent,
                                mergedTree.getRoot().getControl(),
                                counterControl
                        );
                    } else
                    {
                        System.out.println( "canceled with no merge" );;
                    }
                } else if ( counterControl.getProposition() == null
                        && mergedTree.getRoot()
                                .getControl().getProposition() != null )
                {
                    counterArgumentNode = createCounterArgumentViewConclusion(
                            targetParent,
                            mergedTree.getRoot().getControl(),
                            counterControl
                    );
                } else if ( counterControl.getProposition() != null
                        && mergedTree.getRoot()
                                .getControl().getProposition() == null )
                {
                    counterArgumentNode = createCounterArgumentViewPremise(
                            targetParent,
                            mergedTree.getRoot().getControl(),
                            counterControl
                    );;
                }
                attachNewSubTree(
                        counterArgumentNode,
                        target,
                        targetParent,
                        mergedTree,
                        futureChildID
                );
                canvasControl.removeArgumentTree( futureChildID );
                collisionAdjustment();
                canvasControl.constructionAreaSizeCheck();
            }
        } catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class
                    .getName() ).log( Level.SEVERE, null, ex );
        }
    }

    /**
     * Method for chaining arguments to a CQPane controller
     *
     * @param futureChildID
     * @param cqControl
     */
    public void mergeTree( String futureChildID,
            CQPaneController cqControl )
    {
        ArgumentNode target
                = searchForNode( root, cqControl.getMainPane() );
        ArgumentNode targetParent = target.getParent();
        ArgumentViewTree mergedTree = canvasControl.getArgTree( futureChildID );
        ArgumentNode cqArgNode = null;
        mergedTree.deleteCommentPanes();
        deleteCommentPane( target );
        try
        {
            if ( cqControl.getProposition() != null
                    || mergedTree.getRoot()
                            .getControl().getProposition() != null )
            {
                if ( cqControl.getProposition() != null
                        && mergedTree.getRoot()
                                .getControl().getProposition() != null )
                {
                    ChainPropositionChoice userChoice
                            = showPropositionChoiceDialogue();
                    if ( userChoice == ChainPropositionChoice.CONCLUSION )
                    {
                        cqArgNode = createCQArgPaneConclusion(
                                targetParent,
                                mergedTree.getRoot().getControl(),
                                cqControl
                        );
                    } else if ( userChoice == ChainPropositionChoice.PREMISE )
                    {
                        cqArgNode = createCQArgPanePremise(
                                targetParent,
                                mergedTree.getRoot().getControl(),
                                cqControl
                        );
                    } else
                    {
                        System.out.println( "canceled with no merge" );;
                    }
                } else if ( cqControl.getProposition() == null
                        && mergedTree.getRoot()
                                .getControl().getProposition() != null )
                {
                    cqArgNode = createCQArgPaneConclusion(
                            targetParent,
                            mergedTree.getRoot().getControl(),
                            cqControl
                    );
                } else if ( cqControl.getProposition() != null
                        && mergedTree.getRoot()
                                .getControl().getProposition() == null )
                {
                    cqArgNode = createCQArgPanePremise(
                            targetParent,
                            mergedTree.getRoot().getControl(),
                            cqControl
                    );
                }
                attachNewSubTree(
                        cqArgNode,
                        target,
                        targetParent,
                        mergedTree,
                        futureChildID
                );
                canvasControl.removeArgumentTree( futureChildID );
                collisionAdjustment();
                canvasControl.constructionAreaSizeCheck();
            }
        } catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class
                    .getName() ).log( Level.SEVERE, null, ex );
        }
    }

    /**
     * Method for updating the nexus matrix of ArgumentViewTree when merging
     *
     * @param chainNode  ArgumentNode the chain pane connecting the two
     *                   arguments
     * @param mergedTree ArgumentViewTree argument tree being merged into this
     *                   one
     */
    private void updateNexusMatrix(
            ArgumentNode chainNode, ArgumentViewTree mergedTree )
    {
        ArgumentNode chainNodeControllingNexus
                = chainNode.getParent().getParent();
        ListIterator<List<ArgumentNode>> matrixIt = nexusMatrix.listIterator( 0 );
        List<ArgumentNode> targetLayer = null;
        while ( targetLayer == null && matrixIt.hasNext() )
        {
            List<ArgumentNode> inspectedLayer = matrixIt.next();
            for ( ArgumentNode nexus : inspectedLayer )
            {
                if ( nexus.equals( chainNodeControllingNexus ) )
                {
                    targetLayer = inspectedLayer;
                }
            }
        }
        Iterator<List<ArgumentNode>> mergedTreeIt
                = mergedTree.getNexusMatrix().iterator();

        while ( mergedTreeIt.hasNext() )
        {
            if ( !matrixIt.hasNext() )
            {
                List<ArgumentNode> newLayer = new ArrayList<>();
                for ( ArgumentNode nexus : mergedTreeIt.next() )
                {
                    newLayer.add( nexus );
                }
                matrixIt.add( newLayer );
            } else
            {
                targetLayer = matrixIt.next();
                for ( ArgumentNode nexus : mergedTreeIt.next() )
                {
                    targetLayer.add( nexus );
                }
            }
        }
    }

    /**
     * Method for updating the pane matrix of ArgumentViewTree when merging
     *
     * @param replacedNode ArgumentNode being removed from the matrix
     * @param chainNode    ArgumentNode the chain pane connecting the two
     *                     arguments
     * @param mergedTree   ArgumentViewTree argument tree being merged into this
     *                     one
     */
    private void updatePaneMatrix(
            ArgumentNode replacedNode,
            ArgumentNode chainNode,
            ArgumentViewTree mergedTree )
    {
        ListIterator<List<ArgumentNode>> matrixIt = paneMatrix.listIterator( 0 );
        List<ArgumentNode> targetLayer = null;
        while ( targetLayer == null && matrixIt.hasNext() )
        {
            List<ArgumentNode> inspectedLayer = matrixIt.next();
            for ( ArgumentNode pane : inspectedLayer )
            {
                if ( pane.equals( replacedNode ) )
                {
                    targetLayer = inspectedLayer;
                }
            }
        }
        targetLayer.remove( replacedNode );
        mergedTree.replaceInPaneMatrix( mergedTree.getRoot(), chainNode );
        Iterator<List<ArgumentNode>> mergedTreeIt
                = mergedTree.getPaneMatrix().iterator();
        while ( mergedTreeIt.hasNext() )
        {
            for ( ArgumentNode pane : mergedTreeIt.next() )
            {
                targetLayer.add( pane );
            }
            if ( mergedTreeIt.hasNext() )
            {
                if ( !matrixIt.hasNext() )
                {
                    List<ArgumentNode> newLayer = new ArrayList<>();
                    matrixIt.add( newLayer );
                    targetLayer = matrixIt.previous();
                }
                targetLayer = matrixIt.next();
            }
        }
    }

    /**
     * Method for replacing an ArgumentNode in pane matrix with another
     *
     * @param replacee    ArgumentNode to be replaced
     * @param replacement ArgumentNode replacing replacee
     */
    private void replaceInPaneMatrix(
            ArgumentNode replacee,
            ArgumentNode replacement
    )
    {
        List<ArgumentNode> targetLayer = null;
        ListIterator<List<ArgumentNode>> matrixIt = paneMatrix.listIterator( 0 );
        while ( targetLayer == null && matrixIt.hasNext() )
        {
            List<ArgumentNode> inspectedLayer = matrixIt.next();
            for ( ArgumentNode pane : inspectedLayer )
            {
                if ( pane.equals( replacee ) )
                {
                    targetLayer = inspectedLayer;
                }
            }
        }

        targetLayer.remove( replacee );
        targetLayer.add( replacement );
    }

    // Methods for detaching subarguments and CQ's/Counter args
    //--------------------------------------------------------------------------
    /**
     * Method for detaching a sub argument
     *
     * @param chainControl ChainPaneController controller of the chain pane
     *                     acting as the conclusion of the sub argument being
     *                     removed
     * @param coords       Point2D coordinates where the new argument tree will
     *                     be drawn
     */
    public void detachArgumentChain( ChainPaneController chainControl,
            Point2D coords )
    {
        try
        {
            /*
             * get reference to the chain node that is going to be split up and
             * its parent
             */
            ArgumentNode target
                    = searchForNode( root, chainControl.getMainPane() );
            ArgumentNode targetParent = target.getParent();
            deleteCommentPane( target );

            List<ArgumentNode> targetLayer
                    = findMatrixLayer( target, paneMatrix );
            /*
             * get the coordinates for where the new conclusion pane will be
             * drawn
             */
            Point2D targetCoords = new Point2D(
                    target.getView().getLayoutX(),
                    target.getView().getLayoutY()
            );

            /*
             * create the new premise node and splice it in place of the chain
             * node and draw it
             */
            ArgumentNode premiseBox = createPremiseView(
                    chainControl.getPremiseArgument(),
                    targetParent.getView(),
                    chainControl.getPosition()
            );
            targetParent.removeChild( target );
            targetParent.addAsChild( premiseBox );
            premiseBox.setParent( targetParent );
            canvas.getChildren().add( premiseBox.getView() );

            ArgumentNode certaintyBox
                    = createArgumentCertaintyBox(
                            chainControl.getPremiseArgument(),
                            ( PremiseNode ) premiseBox
                    );
            premiseBox.addAsChild( certaintyBox );
            certaintyBox.setParent( premiseBox );
            canvas.getChildren().add( certaintyBox.getView() );

            shrinkParentNexus( premiseBox );
            targetLayer.add( premiseBox );

            /*
             * create a new argument tree to contain the conclusion side of the
             * split
             */
            ArgumentViewTree newArgTree
                    = new ArgumentViewTree( canvas, canvasControl );

            /*
             * make a new conclusion node and attached the branch containing the
             * conclusion side of the chain node to it and draw it
             */
            ConclusionNode newConclusion
                    = createConclusionView(
                            chainControl.getConclusionArgumentModel(),
                            targetCoords
                    );
            newConclusion.getControl().setCertaintyController(
                    chainControl.getCertaintyController()
            );
            if ( chainControl.getProposition() != null )
            {
                newConclusion.getControl().addProposition(
                        chainControl.getProposition()
                );
            }
            newConclusion.setArgTree( newArgTree );
            newArgTree.setRoot( newConclusion );
            ListIterator<ArgumentNode> targetChildren
                    = target.getChildren().listIterator();
            while ( targetChildren.hasNext() )
            {
                ArgumentNode child = targetChildren.next();
                newConclusion.addAsChild( child );
                child.setParent( newConclusion );
                newArgTree.changeArgTree( child );
                targetChildren.remove();
            }
            canvas.getChildren().add( newConclusion.getView() );

            /*
             * shift the newly made argument tree so that it's offset from the
             * premise of the old tree
             */
            double transX = coords.getX() - target.getView().getLayoutX();
            double transY = coords.getY() - target.getView().getLayoutY();
            translateNode( newConclusion, transX, transY );
            removeNodeFromMatrix( paneMatrix, target );
            targetLayer.add( newConclusion );
            /*
             * clean up chain pane and register the new tree with the
             * cinstruction area
             */
            canvas.getChildren().remove( target.getView() );
            canvasControl.registerNewArgTree( newArgTree );

            updateAllCollisionMatricesOnDetach( newArgTree );
            collisionAdjustment();
        } catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class
                    .getName() ).log( Level.SEVERE, null, ex );
        }
    }

    /**
     * Method for detaching a multiple arguments sharing the same conclusion
     * acting as a sub argument
     *
     * @param chainControl MultiArgChainPaneController controller of the pane
     *                     acting as the conclusion of the sub argument being
     *                     removed
     * @param coords       Point2D coordinates where the new argument tree will
     *                     be drawn
     */
    public void detachArgumentChain( MultiArgChainPaneController chainControl,
            Point2D coords )
    {
        try
        {
            /*
             * get reference to the chain node that is going to be split up and
             * its parent
             */
            ArgumentNode target
                    = searchForNode( root, chainControl.getMainPane() );
            ArgumentNode targetParent = target.getParent();
            deleteCommentPane( target );
            List<ArgumentNode> targetLayer
                    = findMatrixLayer( target, paneMatrix );
            /*
             * create the new premise node and splice it in place of the chain
             * node and draw it
             */
            ArgumentNode premiseBox = createPremiseView(
                    chainControl.getPremiseArgument(),
                    targetParent.getView(),
                    chainControl.getPosition()
            );
            targetParent.removeChild( target );
            targetParent.addAsChild( premiseBox );
            premiseBox.setParent( targetParent );
            canvas.getChildren().add( premiseBox.getView() );

            ArgumentNode certaintyBox
                    = createArgumentCertaintyBox(
                            chainControl.getPremiseArgument(),
                            ( PremiseNode ) premiseBox
                    );
            premiseBox.addAsChild( certaintyBox );
            certaintyBox.setParent( premiseBox );
            canvas.getChildren().add( certaintyBox.getView() );

            shrinkParentNexus( premiseBox );
            targetLayer.add( premiseBox );

            /*
             * create a new argument tree to contain the conclusion side of the
             * split
             */
            ArgumentViewTree newArgTree
                    = new ArgumentViewTree( canvas, canvasControl );

            /*
             * make a new conclusion node and attached the branch containing the
             * conclusion side of the chain node to it and draw it
             */
            ConclusionNode newConclusion
                    = createNewMultiArgConclusion(
                            target,
                            chainControl
                    );
            newConclusion.setArgTree( newArgTree );
            newArgTree.setRoot( newConclusion );
            ListIterator<ArgumentNode> targetChildren
                    = target.getChildren().listIterator();
            while ( targetChildren.hasNext() )
            {
                ArgumentNode child = targetChildren.next();
                newConclusion.addAsChild( child );
                child.setParent( newConclusion );
                newArgTree.changeArgTree( child );
                targetChildren.remove();
            }
            canvas.getChildren().add( newConclusion.getView() );

            /*
             * shift the newly made argument tree so that it's offset from the
             * premise of the old tree
             */
            double transX = coords.getX() - target.getView().getLayoutX();
            double transY = coords.getY() - target.getView().getLayoutY();
            translateNode( newConclusion, transX, transY );

            removeNodeFromMatrix( paneMatrix, target );
            targetLayer.add( newConclusion );
            /*
             * clean up chain pane and register the new tree with the
             * cinstruction area
             */
            canvas.getChildren().remove( target.getView() );
            canvasControl.registerNewArgTree( newArgTree );

            updateAllCollisionMatricesOnDetach( newArgTree );
            collisionAdjustment();
        } catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class
                    .getName() ).log( Level.SEVERE, null, ex );
        }
    }

    /**
     * Method for detaching counter arguments from argument structures
     *
     * @param counterChainControl CounterArgumentPaneController controller of
     *                            the pane acting as the conclusion of the
     *                            counter argument being removed
     * @param coords              Point2D coordinates where the new
     *                            ArgumentViewTree will be drawn
     */
    public void detachArgumentChain(
            CounterArgumentPaneController counterChainControl,
            Point2D coords )
    {
        try
        {
            /*
             * get reference to the chain node that is going to be split up and
             * its parent
             */
            ArgumentNode target
                    = searchForNode( root, counterChainControl.getMainPane() );
            ArgumentNode targetParent = target.getParent();
            deleteCommentPane( target );

            List<ArgumentNode> targetLayer
                    = findMatrixLayer( target, paneMatrix );
            /*
             * get the coordinates for where the new conclusion pane will be
             * drawn
             */
            Point2D targetCoords = new Point2D(
                    target.getView().getLayoutX(),
                    target.getView().getLayoutY()
            );

            /*
             * create the new counter premise node and splice it in place of the
             * chain node and draw it. Also replace the arguments in the
             * parent's counter arg list
             */
            CounterArgumentModel counterArg = new CounterArgumentModel();
            counterChainControl.addCounterArgumentToParentModels( counterArg );
            counterChainControl.removeCounterArgumentFromParentModels(
                    counterChainControl.getArgument()
            );

            CounterPropositionNode counterPropBox
                    = ( CounterPropositionNode ) createCounterPropositionView(
                            counterChainControl.getParentModelList(),
                            counterArg,
                            targetParent
                    );
            targetParent.removeChild( target );
            targetParent.addAsChild( counterPropBox );
            counterPropBox.setParent( targetParent );
            canvas.getChildren().add( counterPropBox.getView() );
            shrinkParentNexus( counterPropBox );
            targetLayer.add( counterPropBox );

            ArgumentNode certaintyBox
                    = createArgumentCertaintyBox(
                            counterArg.getConclusion(),
                            ( CounterPropositionNode ) counterPropBox
                    );
            counterPropBox.addAsChild( certaintyBox );
            certaintyBox.setParent( counterPropBox );
            canvas.getChildren().add( certaintyBox.getView() );

            /*
             * replace dechained argument from parent premise and add the new
             * argument
             */
 /*
             * create a new argument tree to contain the conclusion side of the
             * split
             */ ArgumentViewTree newArgTree
                    = new ArgumentViewTree( canvas, canvasControl );

            /*
             * make a new conclusion node and attached the branch containing the
             * conclusion side of the chain node to it and draw it
             */
            //convert counter argument to regular argument
            ArgumentModel newArg
                    = new ArgumentModel(
                            counterChainControl.getArgument()
                    );
            ConclusionNode newConclusion
                    = createConclusionView(
                            newArg,
                            targetCoords
                    );
            newConclusion.getControl().setCertaintyController(
                    counterChainControl.getCertaintyController()
            );
            if ( counterChainControl.getProposition() != null )
            {
                newConclusion.getControl().addProposition(
                        counterChainControl.getProposition()
                );
            }
            newConclusion.setArgTree( newArgTree );
            newArgTree.setRoot( newConclusion );
            ListIterator<ArgumentNode> targetChildren
                    = target.getChildren().listIterator();
            while ( targetChildren.hasNext() )
            {
                ArgumentNode child = targetChildren.next();
                newConclusion.addAsChild( child );
                child.setParent( newConclusion );
                newArgTree.changeArgTree( child );
                targetChildren.remove();
            }
            canvas.getChildren().add( newConclusion.getView() );

            /*
             * shift the newly made argument tree so that it's offset from the
             * premise of the old tree
             */
            double transX = coords.getX() - target.getView().getLayoutX();
            double transY = coords.getY() - target.getView().getLayoutY();
            translateNode( newConclusion, transX, transY );

            removeNodeFromMatrix( paneMatrix, target );
            targetLayer.add( newConclusion );
            /*
             * clean up chain pane and register the new tree with the
             * cinstruction area
             */
            canvas.getChildren().remove( target.getView() );
            canvasControl.registerNewArgTree( newArgTree );

            shrinkCounterArgumentConnection( target );
            updateAllCollisionMatricesOnDetach( newArgTree );
            collisionAdjustment();
        } catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class
                    .getName() ).log( Level.SEVERE, null, ex );
        }
    }

    /**
     * Method for detaching critical question arguments from argument structures
     *
     * @param cqArgControl CQArgumentPaneController controller of the pane
     *                     acting as the conclusion of the counter argument
     *                     being removed
     * @param coords       Point2D coordinates where the new ArgumentViewTree
     *                     will be drawn
     */
    public void detachArgumentChain(
            CQArgumentPaneController cqArgControl,
            Point2D coords )
    {
        try
        {
            /*
             * get reference to the chain node that is going to be split up and
             * its parent
             */
            ArgumentNode target
                    = searchForNode( root, cqArgControl.getMainPane() );
            ArgumentNode targetParent = target.getParent();
            deleteCommentPane( target );

            List<ArgumentNode> targetLayer
                    = findMatrixLayer( target, paneMatrix );
            /*
             * get the coordinates for where the new conclusion pane will be
             * drawn
             */
            Point2D targetCoords = new Point2D(
                    target.getView().getLayoutX(),
                    target.getView().getLayoutY()
            );

            /*
             * create the new CQ premise node and splice it in place of the
             * chain node and draw it. Also replace the arguments in the
             * parent's CQ arg list
             */
            ArgumentModel cqArg = new ArgumentModel();
            cqArgControl.addArgumentToParentCQArgList( cqArg );
            cqArgControl.removeArgumentFromParentCQArgList(
                    cqArgControl.getArgument()
            );

            CQNode cqBox
                    = ( CQNode ) createCQView(
                            cqArg,
                            cqArgControl.getParentArgument(),
                            targetParent
                    );
            targetParent.removeChild( target );
            targetParent.addAsChild( cqBox );
            cqBox.setParent( targetParent );
            canvas.getChildren().add( cqBox.getView() );
            shrinkParentNexus( cqBox );
            targetLayer.add( cqBox );

            ArgumentNode certaintyBox
                    = createArgumentCertaintyBox(
                            cqArg.getConclusion(),
                            cqBox
                    );
            cqBox.addAsChild( certaintyBox );
            certaintyBox.setParent( cqBox );
            canvas.getChildren().add( certaintyBox.getView() );

            /*
             * replace dechained argument from parent premise and add the new
             * argument
             */
 /*
             * create a new argument tree to contain the conclusion side of the
             * split
             */ ArgumentViewTree newArgTree
                    = new ArgumentViewTree( canvas, canvasControl );

            /*
             * make a new conclusion node and attached the branch containing the
             * conclusion side of the chain node to it and draw it
             */
            ConclusionNode newConclusion
                    = createConclusionView(
                            cqArgControl.getArgument(),
                            targetCoords
                    );
            newConclusion.getControl().setCertaintyController(
                    cqArgControl.getCertaintyController()
            );
            if ( cqArgControl.getProposition() != null )
            {
                newConclusion.getControl().addProposition(
                        cqArgControl.getProposition()
                );
            }
            newConclusion.setArgTree( newArgTree );
            newArgTree.setRoot( newConclusion );
            ListIterator<ArgumentNode> targetChildren
                    = target.getChildren().listIterator();
            while ( targetChildren.hasNext() )
            {
                ArgumentNode child = targetChildren.next();
                newConclusion.addAsChild( child );
                child.setParent( newConclusion );
                newArgTree.changeArgTree( child );
                targetChildren.remove();
            }
            canvas.getChildren().add( newConclusion.getView() );

            /*
             * shift the newly made argument tree so that it's offset from the
             * premise of the old tree
             */
            double transX = coords.getX() - target.getView().getLayoutX();
            double transY = coords.getY() - target.getView().getLayoutY();
            translateNode( newConclusion, transX, transY );

            removeNodeFromMatrix( paneMatrix, target );
            targetLayer.add( newConclusion );
            /*
             * clean up chain pane and register the new tree with the
             * cinstruction area
             */
            canvas.getChildren().remove( target.getView() );
            canvasControl.registerNewArgTree( newArgTree );

            updateAllCollisionMatricesOnDetach( newArgTree );
            collisionAdjustment();
        } catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class
                    .getName() ).log( Level.SEVERE, null, ex );
        }
    }

    /**
     * recursively traverses up the tree and shrinks all nexus nodes it finds on
     * the way to root to their default value (determined by the number of
     * premises controlled by the nexus).
     *
     * @param node
     */
    private void shrinkParentNexus( ArgumentNode node )
    {
        // if a premise node is visited
        if ( node instanceof PremiseNexusNode )
        {
            /*
             * cast node to a nexus node and resize to original default size
             */
            PremiseNexusNode nexusNode = ( PremiseNexusNode ) node;
            double amountShrunk = resizeNexusToDefault( nexusNode );
            /*
             * shift node so that it is centered relative to its parent
             */
            nexusNode.getView().setLayoutX(
                    node.getView().getLayoutX() + ( amountShrunk / 2 )
            );
            /*
             * reposition subtrees of nexus so that they are in the correct
             * relative positions
             */
            shiftNexusChildrenOnDetach( nexusNode );
        }
        if ( !node.equals( root ) )
        {
            shrinkParentNexus( node.getParent() );
        }
    }

    /**
     * translates children of nexus nodes to their new positions on the nexus
     * after a nexus is shrunk on a detachment
     *
     * @param nexusNode PremiseNexusNode
     */
    private void shiftNexusChildrenOnDetach( PremiseNexusNode nexusNode )
    {
        int numChildren = nexusNode.getChildren().size();
        for ( int i = 0; i < numChildren; i++ )
        {
            translateNode( nexusNode.getChildren().get( i ),
                    ( nexusNode.getView().getBoundsInParent()
                            .getMinX()
                    - nexusNode.getChildren().get( i ).getView()
                            .getBoundsInParent()
                            .getMinX() )
                    + ( i * ( PREMISE_WIDTH + PADDING ) ),
                    ( nexusNode.getView().getBoundsInParent()
                            .getMaxY()
                    - nexusNode.getChildren().get( i ).getView()
                            .getBoundsInParent()
                            .getMinY() )
            );
        }
    }

    /**
     * resizes a nexus node to it's default size, determined by the number of
     * premises it controls. Returns the amount the nexus was shrunk
     *
     * @param nexus PremiseNexusNode
     *
     * @return double
     */
    private double resizeNexusToDefault( PremiseNexusNode nexus )
    {
        double currentWidth = nexus.getView().getBoundsInParent().getWidth();
        nexus.resizeToDefaultWidth();
        double defaultWidth = nexus.getView().getBoundsInParent().getWidth();
        return ( currentWidth - defaultWidth );
    }

    /**
     * method iterates through the layers of the specified matrices on the
     * detachment of argument subtree and transfers the nexus node references to
     * the new detached tree
     *
     * @param newTree      newly created tree
     * @param parentMatrix tree that the new tree was detached from
     * @param newMatrix    matrix of the new tree
     */
    private void updateMatrixOnDetach(
            ArgumentViewTree newTree,
            List<List<ArgumentNode>> parentMatrix,
            List<List<ArgumentNode>> newMatrix
    )
    {
        ListIterator<List<ArgumentNode>> newMatrixIt
                = newMatrix.listIterator();
        ListIterator<List<ArgumentNode>> parentMatrixIt
                = parentMatrix.listIterator();

        while ( parentMatrixIt.hasNext() )
        {
            //create a new layer to possibly add to the new tree's nexus matrix
            List<ArgumentNode> newTreeNexusLayer = new ArrayList<>();
            List<ArgumentNode> currentSearchLayer = parentMatrixIt.next();
            ListIterator<ArgumentNode> currentSearchLayerIt
                    = currentSearchLayer.listIterator();
            // iterate through a layer of the original matrix
            while ( currentSearchLayerIt.hasNext() )
            {
                ArgumentNode currentNode = currentSearchLayerIt.next();
                if ( newTree.containsNode( currentNode ) )
                {
                    /*
                     * if the new tree contains a nexus found in the old tree's
                     * matrix, add it to the layer created earlier and remove
                     * the reference to that node from the old matrix
                     */
                    newTreeNexusLayer.add( currentNode );
                    currentSearchLayerIt.remove();
                }
            }
            /*
             * if anything was added to the layer made earlier, add it as a
             * layer to the new tree's matrix
             */
            if ( !newTreeNexusLayer.isEmpty() )
            {
                newMatrixIt.add( newTreeNexusLayer );
            }
            /*
             * if the layer we were looking at in the old matrix is now empty,
             * remove that layer
             */
            if ( currentSearchLayer.isEmpty() )
            {
                parentMatrixIt.remove();
            }
        }
    }

    //Adding critical questions to an argument structure
    //--------------------------------------------------------------------------
    public void addCriticalQuestion(
            ArgumentModel arg,
            ArgumentNode schemeLabel,
            int cqNum
    ) throws IOException
    {
        if ( !arg.hasCQ() )
        {
            createNewCQStructure( arg, schemeLabel, cqNum );
            arg.setCQ( true );
        } else
        {
            addAdditionalCriticalQuestion( arg, schemeLabel, cqNum );
        }
    }

    public void addAdditionalCriticalQuestion(
            ArgumentModel parentArg,
            ArgumentNode schemeLabel,
            int cqNum ) throws IOException
    {
        // get main connector
        CQConnectionNode mainConnector = null;
        for ( ArgumentNode child : schemeLabel.getParent().getChildren() )
        {
            if ( child instanceof CQConnectionNode )
            {
                mainConnector = ( CQConnectionNode ) child;
            }
        }

        //get nexus
        PremiseNexusNode nexus
                = ( PremiseNexusNode ) findNextNexus( mainConnector );

        //create a connector for the new counter arg
        ArgumentNode specificCQConnector
                = createPremiseConnection( nexus.getView(), 0 );
        nexus.addAsChild( specificCQConnector );
        specificCQConnector.setParent( nexus );
        canvas.getChildren().add( specificCQConnector.getView() );

        // create new label for CQ
        ArgumentNode cqLabel = new CQLabel(
                parentArg.getPatchCriticalQuestion( cqNum ),
                getRelativeLayout( specificCQConnector.getView() ),
                this,
                canvas,
                specificCQConnector
        );
        cqLabel.setParent( specificCQConnector );
        specificCQConnector.addAsChild( cqLabel );
        canvas.getChildren().add( cqLabel.getView() );

        // create new CQ pane
        ArgumentModel newArg = new ArgumentModel();
        ArgumentNode cqPremise = createCQView(
                newArg,
                parentArg,
                specificCQConnector
        );
        specificCQConnector.addAsChild( cqPremise );
        cqPremise.setParent( specificCQConnector );
        canvas.getChildren().add( cqPremise.getView() );

        ArgumentNode certaintyBox
                = createArgumentCertaintyBox(
                        newArg.getConclusion(),
                        ( CQNode ) cqPremise
                );
        cqPremise.addAsChild( certaintyBox );
        certaintyBox.setParent( cqPremise );
        canvas.getChildren().add( certaintyBox.getView() );

        // adjust nexus size
        double amountShrunk = resizeNexusToDefault( nexus );
        /*
         * shift node so that it is centered relative to its parent
         */
        nexus.getView().setLayoutX(
                nexus.getView().getLayoutX()
                + ( amountShrunk / 2 )
        );
        /*
         * reposition subtrees of nexus so that they are in the correct relative
         * positions
         */
        shiftNexusChildrenOnDetach( nexus );
        /*
         * add new CQ pane to matrix
         */
        // add CQ pane
        List<ArgumentNode> targetLayer
                = paneMatrix.get( paneMatrix.indexOf(
                        findMatrixLayer(
                                schemeLabel.getParent(), paneMatrix
                        )
                )
                        + 1
                );
        targetLayer.add( cqPremise );

        collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();
    }

    private void createNewCQStructure(
            ArgumentModel parentArg,
            ArgumentNode schemeLabel,
            int cqNum
    ) throws IOException
    {
        ArgumentNode mainCQConnector = createCQConnection( parentArg, schemeLabel.getParent() );
        schemeLabel.getParent().addAsChild( mainCQConnector );
        mainCQConnector.setParent( schemeLabel.getParent() );
        canvas.getChildren().add( mainCQConnector.getView() );

        ArgumentNode cqIcon = createCQIcon( mainCQConnector );
        cqIcon.setParent( mainCQConnector );
        mainCQConnector.addAsChild( cqIcon );
        canvas.getChildren().add( cqIcon.getView() );

        ArgumentNode nexus
                = createNexus(
                        1,
                        cqIcon.getView()
                );
        cqIcon.addAsChild( nexus );
        nexus.setParent( cqIcon );
        canvas.getChildren().add( nexus.getView() );
        /*
         * add new nexus to matrix
         */
        List<ArgumentNode> targetNexusLayer
                = nexusMatrix.get( nexusMatrix.indexOf(
                        findMatrixLayer(
                                findNextNexus(
                                        schemeLabel.getParent()
                                ), nexusMatrix
                        )
                ) );
        targetNexusLayer.add( nexus );

        ArgumentNode cqConnect
                = createPremiseConnection( nexus.getView(), 0 );
        nexus.addAsChild( cqConnect );
        cqConnect.setParent( nexus );
        canvas.getChildren().add( cqConnect.getView() );

        ArgumentNode cqLabel = new CQLabel(
                parentArg.getPatchCriticalQuestion( cqNum ),
                getRelativeLayout( cqConnect.getView() ),
                this,
                canvas,
                cqConnect
        );
        cqLabel.setParent( cqConnect );
        cqConnect.addAsChild( cqLabel );
        canvas.getChildren().add( cqLabel.getView() );

        ArgumentModel newArg = new ArgumentModel();
        ArgumentNode cqPremise = createCQView(
                newArg,
                parentArg,
                cqConnect
        );
        cqConnect.addAsChild( cqPremise );
        cqPremise.setParent( cqConnect );
        canvas.getChildren().add( cqPremise.getView() );

        ArgumentNode certaintyBox
                = createArgumentCertaintyBox(
                        newArg.getConclusion(),
                        ( CQNode ) cqPremise
                );
        cqPremise.addAsChild( certaintyBox );
        certaintyBox.setParent( cqPremise );
        canvas.getChildren().add( certaintyBox.getView() );

        /*
         * add new CQ pane to matrix
         */
        // add CQ pane
        List<ArgumentNode> targetPaneLayer
                = paneMatrix.get( paneMatrix.indexOf(
                        findMatrixLayer( schemeLabel.getParent(), paneMatrix
                        )
                )
                        + 1
                );
        targetPaneLayer.add( cqPremise );

        collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();
    }

    public void deleteCriticalQuestion( CQPaneController controller )
    {
        /*
         * get node reference to the CQ that is going to deleted
         */
        ArgumentNode target
                = searchForNode( root, controller.getMainPane() );
        deleteCommentPane( target );
        ArgumentNode targetConnector = target.getParent();
        ArgumentNode targetNexus = targetConnector.getParent();

        /*
         * remove pane and connector from structure
         */
        ListIterator<ArgumentNode> childIT
                = targetNexus.getChildren().listIterator();
        while ( childIT.hasNext() )
        {
            ArgumentNode child = childIT.next();
            if ( child.equals( targetConnector ) )
            {
                eraseTree( child );
                childIT.remove();
            }
        }
        eraseTree( targetConnector );
        removeSubTreeFromMatrices( target );

        /*
         * resize nexus to accomidate new number of children
         */
        //cast node to a nexus node and resize to original default size
        PremiseNexusNode nexusNode = ( PremiseNexusNode ) targetNexus;
        double amountShrunk = resizeNexusToDefault( nexusNode );
        //shift node so that it is centered relative to its parent
        nexusNode.getView().setLayoutX(
                targetNexus.getView().getLayoutX() + ( amountShrunk / 2 )
        );
        //reposition subtrees of nexus so that they are in the correct
        //relative positions
        shiftNexusChildrenOnDetach( nexusNode );
        /*
         * check if we need to remove the counter argument structure i.e. if
         * there are no arguments left in the structure
         */
        if ( targetNexus.getChildren().isEmpty() )
        {
            // remove nexus
            canvas.getChildren().remove( targetNexus.getView() );
            //remove icon
            ArgumentNode cqIcon = targetNexus.getParent();
            canvas.getChildren().remove( cqIcon.getView() );
            //remove horizontal connector
            ArgumentNode horizontalIcon = cqIcon.getParent();
            canvas.getChildren().remove( horizontalIcon.getView() );
            //remove logical reference to the structure
            horizontalIcon.getParent().removeChild( horizontalIcon );
            // resent counter argument flag in parent argument
            controller.getParentArgument().setCQ( false );
        }
        collisionAdjustment();
    }

    // Adding counter arguments to an argument structure
    //--------------------------------------------------------------------------
    public void addCounterArgument(
            List<PremiseModel> targetModelList,
            ArgumentNode parent
    ) throws IOException
    {
        if ( !containsCounterArguments( targetModelList ) )
        {
            addCounterArgumentPane( targetModelList, parent );
        } else
        {
            addAdditionalCounterArg( targetModelList, parent );
        }
    }

    public void addCounterArgument(
            PremiseModel targetModel,
            ArgumentNode parent
    ) throws IOException
    {
        List<PremiseModel> targetModelList = new ArrayList<>();
        targetModelList.add( targetModel );
        if ( !containsCounterArguments( targetModelList ) )
        {
            addCounterArgumentPane( targetModelList, parent );
        } else
        {
            addAdditionalCounterArg( targetModelList, parent );
        }
    }

    private boolean containsCounterArguments( List<PremiseModel> modelList )
    {
        for ( PremiseModel model : modelList )
        {
            if ( model.hasCounterArgument() )
            {
                return true;
            }
        }
        return false;
    }

    private void addAdditionalCounterArg(
            List<PremiseModel> parentModelList,
            ArgumentNode parent ) throws IOException
    {
        //find the counter arg connection
        CounterArgumentConnectionNode rootConnector = null;
        for ( ArgumentNode child : parent.getChildren() )
        {
            if ( child instanceof CounterArgumentConnectionNode )
            {
                rootConnector = ( CounterArgumentConnectionNode ) child;
            }
        }
        // get the matrix layer below the parent node
        List<ArgumentNode> targetMatrixLayer
                = paneMatrix.get(
                        paneMatrix.indexOf(
                                findMatrixLayer( parent, paneMatrix )
                        )
                        + 1
                );
        //get nexus
        PremiseNexusNode nexus
                = ( PremiseNexusNode ) findNextNexus( rootConnector );

        //create a connector for the new counter arg
        ArgumentNode specificCounterConnector
                = createPremiseConnection( nexus.getView(), 0 );
        nexus.addAsChild( specificCounterConnector );
        specificCounterConnector.setParent( nexus );
        canvas.getChildren().add( specificCounterConnector.getView() );

        /*
         * create new argument model for counter argument and a new pane for
         * counter arg
         */
        CounterArgumentModel counterArg = new CounterArgumentModel();
        ArgumentNode counterPane
                = createCounterPropositionView(
                        parentModelList,
                        counterArg,
                        specificCounterConnector
                );
        specificCounterConnector.addAsChild( counterPane );
        counterPane.setParent( specificCounterConnector );
        canvas.getChildren().add( counterPane.getView() );
        //add counter argument to parent arg's counter argument list
        for ( PremiseModel model : parentModelList )
        {
            model.addCounterArgument( counterArg );
        }
        // add counter counter pane to matrix
        targetMatrixLayer.add( counterPane );

        ArgumentNode certaintyBox
                = createArgumentCertaintyBox(
                        counterArg.getConclusion(),
                        ( CounterPropositionNode ) counterPane
                );
        counterPane.addAsChild( certaintyBox );
        certaintyBox.setParent( counterPane );
        canvas.getChildren().add( certaintyBox.getView() );

        // adjust nexus size
        double amountShrunk = resizeNexusToDefault( nexus );
        /*
         * shift node so that it is centered relative to its parent
         */
        nexus.getView().setLayoutX(
                nexus.getView().getLayoutX()
                + ( amountShrunk / 2 )
        );
        /*
         * reposition subtrees of nexus so that they are in the correct relative
         * positions
         */
        shiftNexusChildrenOnDetach( nexus );

        collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();
    }

    private void addCounterArgumentPane(
            List<PremiseModel> parentModelList,
            ArgumentNode parent
    ) throws IOException
    {
        ArgumentNode counterConnector
                = createCounterArgumentConnection( parent.getView() );
        parent.addAsChild( counterConnector );
        counterConnector.setParent( parent );
        canvas.getChildren().add( counterConnector.getView() );

        ArgumentNode counterIcon = createCounterIcon( counterConnector );
        counterIcon.setParent( counterConnector );
        counterConnector.addAsChild( counterIcon );
        canvas.getChildren().add( counterIcon.getView() );

        ArgumentNode counterSecondaryConnector
                = createPremiseConnection( counterIcon.getView(), 0 );
        counterIcon.addAsChild( counterSecondaryConnector );
        counterSecondaryConnector.setParent( counterIcon );
        canvas.getChildren().add( counterSecondaryConnector.getView() );
        translateNode( counterSecondaryConnector, 60 - 3, 0 );

        ArgumentNode nexus
                = createNexus(
                        1,
                        counterSecondaryConnector.getView()
                );
        counterSecondaryConnector.addAsChild( nexus );
        nexus.setParent( counterSecondaryConnector );
        canvas.getChildren().add( nexus.getView() );
        /*
         * add nexus to matrix
         */
        List<ArgumentNode> targetNexusLayer
                = findMatrixLayer( findNextNexus( parent ), nexusMatrix );
        targetNexusLayer.add( nexus );

        ArgumentNode specificCounterConnector
                = createPremiseConnection( nexus.getView(), 0 );
        nexus.addAsChild( specificCounterConnector );
        specificCounterConnector.setParent( nexus );
        canvas.getChildren().add( specificCounterConnector.getView() );

        // create new argument model for counter argument
        CounterArgumentModel counterArg = new CounterArgumentModel();
        ArgumentNode counterPane
                = createCounterPropositionView(
                        parentModelList,
                        counterArg,
                        specificCounterConnector
                );
        specificCounterConnector.addAsChild( counterPane );
        counterPane.setParent( specificCounterConnector );
        canvas.getChildren().add( counterPane.getView() );
        //add counter argument to parent arg's counter argument list
        for ( PremiseModel model : parentModelList )
        {
            model.addCounterArgument( counterArg );
        }

        ArgumentNode certaintyBox
                = createArgumentCertaintyBox(
                        counterArg.getConclusion(),
                        ( CounterPropositionNode ) counterPane
                );
        counterPane.addAsChild( certaintyBox );
        certaintyBox.setParent( counterPane );
        canvas.getChildren().add( certaintyBox.getView() );

        updateNexusMatrix( parent, counterIcon, counterPane );
        collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();
    }

    public void deleteCounterArgument(
            CounterArgumentPaneController controller,
            List<PremiseModel> parentModelList,
            CounterArgumentModel counterArgument )
    {
        /*
         * get reference to the counter argument that is going to deleted
         */
        ArgumentNode target
                = searchForNode( root, controller.getMainPane() );
        deleteCommentPane( target );
        deleteCounterArgument(
                target,
                counterArgument,
                parentModelList
        );

    }

    public void deleteCounterArgument(
            CounterPropositionPaneController controller,
            List<PremiseModel> parentModelList,
            CounterArgumentModel counterArgument )
    {
        /*
         * get reference to the counter argument that is going to deleted
         */
        ArgumentNode target
                = searchForNode( root, controller.getMainPane() );
        deleteCommentPane( target );
        deleteCounterArgument(
                target,
                counterArgument,
                parentModelList
        );
    }

    private void deleteCounterArgument(
            ArgumentNode target,
            CounterArgumentModel counterArgument,
            List<PremiseModel> parentCounterArgumentList )
    {

        // Get connector nodes
        ArgumentNode targetConnector = target.getParent();
        ArgumentNode targetNexus = targetConnector.getParent();
        deleteCommentPane( target );
        /*
         * remove pane and connector from structure
         */
        ListIterator<ArgumentNode> childIT
                = targetNexus.getChildren().listIterator();
        while ( childIT.hasNext() )
        {
            ArgumentNode child = childIT.next();
            if ( child.equals( targetConnector ) )
            {
                childIT.remove();
            }
        }
        eraseTree( targetConnector );
        removeSubTreeFromMatrices( target );

        // remove counter argument from parent counter arg list
        for ( PremiseModel parentModel : parentCounterArgumentList )
        {
            parentModel.getCounterArgumentList().remove( counterArgument );
        }

        /*
         * resize nexus to accomidate new number of children
         */
        //cast node to a nexus node and resize to original default size
        PremiseNexusNode nexusNode = ( PremiseNexusNode ) targetNexus;
        double amountShrunk = resizeNexusToDefault( nexusNode );
        //shift node so that it is centered relative to its parent
        nexusNode.getView().setLayoutX(
                targetNexus.getView().getLayoutX() + ( amountShrunk / 2 )
        );
        //reposition subtrees of nexus so that they are in the correct
        //relative positions
        shiftNexusChildrenOnDetach( nexusNode );

        /*
         * check if we need to remove the counter argument structure i.e. if
         * there are no arguments left in the structure
         */
        if ( targetNexus.getChildren().isEmpty() )
        {
            // undraw nexus
            canvas.getChildren().remove( targetNexus.getView() );
            removeNodeFromMatrix( nexusMatrix, targetNexus );
            //remove vertiacl connection
            ArgumentNode verticalConnector = targetNexus.getParent();
            canvas.getChildren().remove( verticalConnector.getView() );
            //remove icon
            ArgumentNode counterIcon = verticalConnector.getParent();
            canvas.getChildren().remove( counterIcon.getView() );
            removeNodeFromMatrix( paneMatrix, counterIcon );
            //remove horizontal connector
            ArgumentNode horizontalIcon = counterIcon.getParent();
            canvas.getChildren().remove( horizontalIcon.getView() );
            // shrink parent nexuses
            shrinkParentNexus( horizontalIcon.getParent() );
            //remove logical reference to the structure
            horizontalIcon.getParent().removeChild( horizontalIcon );
        }
        collisionAdjustment();
    }

    /**
     * Shrink the counter argument connection that counterPane is attached to
     * and shift over all related elements in the sub-tree to the new position
     *
     * @param counterPane ArgumentNode a counter argument pane
     */
    private void shrinkCounterArgumentConnection( ArgumentNode counterPane )
    {
        /*
         * cast node to a nexus node and resize to original default size
         */
        CounterArgumentConnectionNode counterConnection
                = ( CounterArgumentConnectionNode ) findCounterConnection(
                        counterPane
                );
        double amountShrunk
                = resizeCounterConnectionToDefault( counterConnection );

        /*
         * reposition subtrees of nexus so that they are in the correct relative
         * positions
         */
        for ( ArgumentNode child : counterConnection.getChildren() )
        {
            translateNode( child, -amountShrunk, 0 );
        }
    }

    /**
     * Resizes a counter connection to its default size
     *
     * @param counterConnection ArgumentNode
     *
     * @return double amount shrunk
     */
    private double resizeCounterConnectionToDefault(
            CounterArgumentConnectionNode counterConnection )
    {
        double currentWidth
                = counterConnection.getView().getBoundsInParent().getWidth();
        counterConnection.resizeToDefaultWidth();
        double defaultWidth
                = counterConnection.getView().getBoundsInParent().getWidth();
        return ( currentWidth - defaultWidth );
    }

    /**
     * Recurses up an argument tree to find the first ancestor that is an
     * instance of a CounterArgumentConnectionNode
     *
     * @param node ArgumentNode being inspected
     *
     * @return CounterArgumentConnectionNode
     */
    private CounterArgumentConnectionNode findCounterConnection(
            ArgumentNode node )
    {
        if ( node != null )
        {
            if ( node instanceof CounterArgumentConnectionNode )
            {
                return ( CounterArgumentConnectionNode ) node;
            }
            return findCounterConnection( node.getParent() );
        }
        return null;
    }

    // Methods for handeling Multiple arguments supporting the same conclusion
    //--------------------------------------------------------------------------
    public void createMultiArgBranch( String mergeTreeID,
            ConclusionPaneController mainTreeControl ) throws IOException
    {
        int numPremises = 2;
        ArgumentViewTree mergedTree = canvasControl.getArgTree( mergeTreeID );
        mergedTree.deleteCommentPanes();
        ConclusionNode mergeTreeRoot = mergedTree.getRoot();
        if ( !( mergeTreeRoot.getControl() instanceof MultiArgConclusionPaneController ) )
        {
            ConclusionNode mainConNode
                    = ( ConclusionNode ) searchForNode(
                            root,
                            mainTreeControl.getMainPane()
                    );

            ArgumentNode targetMatrix = findNextNexus( mainConNode );
            List<ArgumentNode> targetNexusMatrixLayer
                    = findMatrixLayer( targetMatrix, nexusMatrix );
            List<ArgumentNode> targetPaneMatrixLayer
                    = findMatrixLayer( mainConNode, paneMatrix );

            ConclusionNode newConclusion
                    = createNewMultiArgConclusion(
                            mainConNode,
                            mainTreeControl,
                            mergeTreeRoot.getControl()
                    );

            root = newConclusion;

            ArgumentNode connector
                    = createConclusionConnector( root.getView() );
            root.addAsChild( connector );
            connector.setParent( root );
            canvas.getChildren().add( connector.getView() );

            ArgumentNode label
                    = createMultiArgLabel( root.getView() );
            root.addAsChild( label );
            label.setParent( root );
            canvas.getChildren().add( label.getView() );

            ArgumentNode nexus = createNexus( numPremises, connector.getView() );
            connector.addAsChild( nexus );
            nexus.setParent( connector );
            canvas.getChildren().add( nexus.getView() );

            ArgumentNode multiArgPremiseConnect
                    = createMultiArgPremiseConnection( nexus.getView(), 0 );
            nexus.addAsChild( multiArgPremiseConnect );
            multiArgPremiseConnect.setParent( nexus );
            canvas.getChildren().add( multiArgPremiseConnect.getView() );

            ArgumentNode multiArgSub = createMultiArgSubView(
                    mainConNode.getControl().getConclusionArgumentModel(),
                    multiArgPremiseConnect.getView(),
                    mainConNode.getControl().getCertaintyController(),
                    0
            );

            multiArgPremiseConnect.addAsChild( multiArgSub );
            multiArgSub.setParent( multiArgPremiseConnect );
            canvas.getChildren().add( multiArgSub.getView() );

            replaceConnectorWithMultiArgConnector( mainConNode );

            translateNode( mainConNode,
                    multiArgSub.getView().getBoundsInParent().getMinX()
                    - mainConNode.getView().getBoundsInParent().getMinX()
                    - ( ( PREMISE_WIDTH - 40 ) / 2 ),
                    multiArgSub.getView().getBoundsInParent().getMinY()
                    - mainConNode.getView().getBoundsInParent().getMinY()
                    - ( PREMISE_HEIGHT - 40 )
            );
            ListIterator<ArgumentNode> mainConChildrenIT
                    = mainConNode.getChildren().listIterator();
            while ( mainConChildrenIT.hasNext() )
            {
                ArgumentNode child = mainConChildrenIT.next();
                multiArgSub.addAsChild( child );
                child.setParent( multiArgSub );
                mainConChildrenIT.remove();
            }
            for ( ArgumentNode node : multiArgSub.getChildren() )
            {
                if ( node instanceof ArgumentCertaintyNode )
                {
                    node.getView().setLayoutX( node.getView().getLayoutX() - 85 );
                }
                if ( node instanceof CQConnectionNode
                        || node instanceof ArgumentSchemeLabel )
                {
                    translateNode( node, 0, 205 );
                }
            }
            replaceInPaneMatrix( mainConNode, multiArgSub );

            ArgumentNode multiArgPremiseConnectB
                    = createMultiArgPremiseConnection( nexus.getView(), 1 );
            nexus.addAsChild( multiArgPremiseConnectB );
            multiArgPremiseConnectB.setParent( nexus );
            canvas.getChildren().add( multiArgPremiseConnectB.getView() );

            ArgumentNode multiArgSubB = createMultiArgSubView(
                    mergeTreeRoot.getControl().getConclusionArgumentModel(),
                    multiArgPremiseConnectB.getView(),
                    mergeTreeRoot.getControl().getCertaintyController(),
                    1
            );

            replaceConnectorWithMultiArgConnector( mergeTreeRoot );

            multiArgPremiseConnectB.addAsChild( multiArgSubB );
            multiArgSubB.setParent( multiArgPremiseConnectB );
            canvas.getChildren().add( multiArgSubB.getView() );
            mergedTree.translateTree(
                    multiArgSubB.getView().getBoundsInParent().getMinX()
                    - ( ( PREMISE_WIDTH - 40 ) / 2 ),
                    multiArgSubB.getView().getBoundsInParent().getMinY()
                    - ( PREMISE_HEIGHT - 40 )
            );
            ListIterator<ArgumentNode> mergeConChildrenIT
                    = mergedTree.getRoot().getChildren().listIterator();
            while ( mergeConChildrenIT.hasNext() )
            {
                ArgumentNode child = mergeConChildrenIT.next();
                multiArgSubB.addAsChild( child );
                child.setParent( multiArgSubB );
                mergeConChildrenIT.remove();
            }
            for ( ArgumentNode node : multiArgSubB.getChildren() )
            {
                if ( node instanceof ArgumentCertaintyNode )
                {
                    node.getView().setLayoutX( node.getView().getLayoutX() - 85 );
                }
                if ( node instanceof CQConnectionNode
                        || node instanceof ArgumentSchemeLabel )
                {
                    translateNode( node, 0, 205 );
                }
            }
            mergedTree.replaceInPaneMatrix( mergedTree.getRoot(), multiArgSubB );

            changeArgTree( root );

            canvas.getChildren().add( newConclusion.getView() );
            canvas.getChildren().remove( mainConNode.getView() );

            canvasControl.removeArgumentTree( mergeTreeID );
            canvas.getChildren().remove( mergeTreeRoot.getView() );

            mergeMatrices(
                    targetPaneMatrixLayer,
                    paneMatrix,
                    mergedTree.paneMatrix
            );
            mergeMatrices(
                    targetNexusMatrixLayer,
                    nexusMatrix,
                    mergedTree.nexusMatrix
            );
            updateNexusMatrixShiftForward( nexus, paneMatrix );
            updateNexusMatrixShiftForward( nexus, nexusMatrix );
            targetPaneMatrixLayer.add( newConclusion );
            targetNexusMatrixLayer.add( nexus );
            mergeCounterArguments(
                    newConclusion,
                    multiArgSub,
                    multiArgSubB
            );

            printMatrix( nexusMatrix );
            collisionAdjustment();
            canvasControl.constructionAreaSizeCheck();
        }
    }

    /**
     * Method for merging the counter arguments of two structures when creating
     * a multiple arguments sharing the same conclusion structure
     *
     * @param parentNode
     * @param subA
     * @param subB
     *
     * @throws IOException
     */
    private void mergeCounterArguments(
            ConclusionNode parentNode,
            ArgumentNode subA,
            ArgumentNode subB ) throws IOException
    {
        ConclusionPaneController parentController
                = parentNode.getControl();
        List<ArgumentModel> argumentList
                = parentController.getConclusionArgumentModelList();

        // gather counter arguments
        List<CounterArgumentModel> consolidatedCounterArguments = new ArrayList<>();
        for ( ArgumentModel argument : argumentList )
        {
            // temp reference to counter arg list for this conclusion
            List<CounterArgumentModel> currentCounterArguments
                    = argument.getConclusion().getCounterArgumentList();
            //transfer over counter arguments to consolidated list
            for ( CounterArgumentModel counterArg : currentCounterArguments )
            {
                consolidatedCounterArguments.add( counterArg );
            }
            // clear this list. Will be populated later with consolidated list
            currentCounterArguments.clear();
        }

        if ( !consolidatedCounterArguments.isEmpty() )
        {
            for ( ArgumentModel argument : argumentList )
            {
                // temp reference to counter arg list for this conclusion
                List<CounterArgumentModel> currentCounterArguments
                        = argument.getConclusion().getCounterArgumentList();
                //copy consolidated list to current conclusion's counter list
                currentCounterArguments.addAll( consolidatedCounterArguments );
                //make sure that counter arguments have references to their
                //parent models
                for ( CounterArgumentModel counterArg : consolidatedCounterArguments )
                {
                    counterArg.addToParentModelList( argument.getConclusion() );
                }
            }
            /*
             * create new counter arg structure for the multi-arg structure
             */
            // create the connector for the coutner arg structure
            ArgumentNode counterConnector
                    = createCounterArgumentConnection( parentNode.getView() );
            parentNode.addAsChild( counterConnector );
            counterConnector.setParent( parentNode );
            canvas.getChildren().add( counterConnector.getView() );

            // create shield icon
            ArgumentNode counterIcon = createCounterIcon( counterConnector );
            counterIcon.setParent( counterConnector );
            counterConnector.addAsChild( counterIcon );
            canvas.getChildren().add( counterIcon.getView() );
            // add new counter icon to matrix
            paneMatrix
                    .get(
                            paneMatrix.indexOf(
                                    findMatrixLayer( parentNode, paneMatrix )
                            )
                    )
                    .add( counterIcon );

            // create the connector between the shield and the counter arg nexus
            ArgumentNode counterSecondaryConnector
                    = createPremiseConnection( counterIcon.getView(), 0 );
            counterIcon.addAsChild( counterSecondaryConnector );
            counterSecondaryConnector.setParent( counterIcon );
            canvas.getChildren().add( counterSecondaryConnector.getView() );
            translateNode( counterSecondaryConnector, 60, 0 );

            // create counter arg nexus
            PremiseNexusNode nexus
                    = ( PremiseNexusNode ) createNexus(
                            1,
                            counterSecondaryConnector.getView()
                    );
            counterSecondaryConnector.addAsChild( nexus );
            nexus.setParent( counterSecondaryConnector );
            canvas.getChildren().add( nexus.getView() );
            // add new nexus to matrix
            nexusMatrix
                    .get(
                            nexusMatrix.indexOf(
                                    findMatrixLayer(
                                            findNextNexus( parentNode ),
                                            nexusMatrix
                                    )
                            )
                    )
                    .add( nexus );

            int targetPaneLayerIndex
                    = paneMatrix.indexOf(
                            findMatrixLayer( parentNode, paneMatrix )
                    ) + 1;
            int targetNexusLayerIndex
                    = nexusMatrix.indexOf(
                            findMatrixLayer(
                                    findNextNexus( parentNode ),
                                    paneMatrix
                            )
                    ) + 1;

            // find specific counter argument connections for mainConNode counters
            ArgumentNode counterConnectionNode = null;
            for ( ArgumentNode child : subA.getChildren() )
            {
                if ( child instanceof CounterArgumentConnectionNode )
                {
                    counterConnectionNode = child;
                }
            }
            if ( counterConnectionNode != null )
            {
                // remove counter icon from matrix
                removeNodeFromMatrix(
                        paneMatrix,
                        counterConnectionNode.getChildren().get( 0 )
                );
                //remove nexus from matrix
                removeNodeFromMatrix(
                        nexusMatrix,
                        findNextNexus( counterConnectionNode )
                );

                ListIterator<ArgumentNode> mainConSpecificCounterConnectors
                        = findNextNexus( counterConnectionNode ).getChildren().listIterator();
                //translate counter arguments and reassign parents/children
                while ( mainConSpecificCounterConnectors.hasNext() )
                {
                    ArgumentNode connector = mainConSpecificCounterConnectors.next();

                    Point2D layout = getRelativeLayout( nexus.getView() );
                    Point2D adjustedLayout = new Point2D(
                            layout.getX() - nexus.getView().getBoundsInParent().getWidth() / 2,
                            layout.getY()
                    );
                    translateNode( connector,
                            adjustedLayout.getX() - connector.getView().getLayoutX(),
                            adjustedLayout.getY() - connector.getView().getLayoutY()
                    );

                    // reassigne relations
                    nexus.addAsChild( connector );
                    mainConSpecificCounterConnectors.remove();
                    connector.setParent( nexus );

                    // update matrix
                    shiftCounterArgumentInMatrix(
                            paneMatrix,
                            connector,
                            targetPaneLayerIndex
                    );
                    shiftCounterArgumentInMatrix(
                            nexusMatrix,
                            connector,
                            targetNexusLayerIndex
                    );

                    printMatrix( nexusMatrix );
                    // adjust nexus size
                    double amountShrunk = resizeNexusToDefault( nexus );
                    /*
                     * shift node so that it is centered relative to its parent
                     */
                    nexus.getView().setLayoutX(
                            nexus.getView().getLayoutX()
                            + ( amountShrunk / 2 )
                    );
                    /*
                     * reposition subtrees of nexus so that they are in the
                     * correct relative positions
                     */
                    shiftNexusChildrenOnDetach( nexus );
                }
                //undraw old counter arg structures
                counterConnectionNode.getParent().removeChild( counterConnectionNode );
                counterConnectionNode.setParent( null );
                eraseTree( counterConnectionNode );
            }

            // find specific counter argument connections for mergeRoot counters
            ArgumentNode counterConnectionNode2 = null;
            for ( ArgumentNode child : subB.getChildren() )
            {
                if ( child instanceof CounterArgumentConnectionNode )
                {
                    counterConnectionNode2 = child;
                }
            }

            if ( counterConnectionNode2 != null )
            {
                // remove counter icon from matrix
                removeNodeFromMatrix(
                        paneMatrix,
                        counterConnectionNode2.getChildren().get( 0 )
                );
                // remove nexus from matrix
                removeNodeFromMatrix(
                        nexusMatrix,
                        findNextNexus( counterConnectionNode2 )
                );

                ListIterator<ArgumentNode> mergeRootSpecificCounterConnectors
                        = findNextNexus( counterConnectionNode2 ).getChildren().listIterator();
                //translate counter arguments and reassign parents/children
                while ( mergeRootSpecificCounterConnectors.hasNext() )
                {
                    ArgumentNode connector = mergeRootSpecificCounterConnectors.next();

                    Point2D layout = getRelativeLayout( nexus.getView() );
                    Point2D adjustedLayout = new Point2D(
                            layout.getX() - nexus.getView().getBoundsInParent().getWidth() / 2,
                            layout.getY()
                    );
                    translateNode( connector,
                            adjustedLayout.getX() - connector.getView().getLayoutX(),
                            adjustedLayout.getY() - connector.getView().getLayoutY()
                    );

                    // reassigne relations
                    nexus.addAsChild( connector );
                    mergeRootSpecificCounterConnectors.remove();
                    connector.setParent( nexus );

                    // update matrix
                    shiftCounterArgumentInMatrix(
                            paneMatrix,
                            connector,
                            targetPaneLayerIndex
                    );
                    shiftCounterArgumentInMatrix(
                            nexusMatrix,
                            connector,
                            targetNexusLayerIndex
                    );

                    // adjust nexus size
                    double amountShrunk = resizeNexusToDefault( nexus );
                    /*
                     * shift node so that it is centered relative to its parent
                     */
                    nexus.getView().setLayoutX(
                            nexus.getView().getLayoutX()
                            + ( amountShrunk / 2 )
                    );
                    /*
                     * reposition subtrees of nexus so that they are in the
                     * correct relative positions
                     */
                    shiftNexusChildrenOnDetach( nexus );
                }
                //undraw old counter arg structures
                counterConnectionNode2.getParent().removeChild( counterConnectionNode2 );
                counterConnectionNode2.setParent( null );
                eraseTree( counterConnectionNode2 );
            }
            collisionAdjustment();
        }
    }

    private void shiftCounterArgumentInMatrix(
            List<List<ArgumentNode>> matrix,
            ArgumentNode subTreeRoot,
            int targetLayerIndex )
    {
        List<ArgumentNode> targetLayer = matrix.get( targetLayerIndex );
        ListIterator<List<ArgumentNode>> currentLayerIT
                = matrix.listIterator( targetLayerIndex + 1 );

        while ( currentLayerIT.hasNext() )
        {
            boolean swapOccured = false;
            List<ArgumentNode> currentLayer = currentLayerIT.next();
            ListIterator<ArgumentNode> currentNodeIT
                    = currentLayer.listIterator();
            while ( currentNodeIT.hasNext() )
            {
                ArgumentNode currentNode = currentNodeIT.next();
                if ( containsNode( subTreeRoot, currentNode ) )
                {
                    currentNodeIT.remove();
                    targetLayer.add( currentNode );
                    swapOccured = true;
                }
            }

            if ( swapOccured )
            {
                targetLayerIndex++;
                targetLayer = matrix.get( targetLayerIndex );
            }
        }

        if ( currentLayerIT.previous().isEmpty() )
        {
            currentLayerIT.remove();
        }
    }

    private void replaceConnectorWithMultiArgConnector( ArgumentNode conNode )
    {
        ArgumentNode multiArgConnector = createMultiArgConnector(
                conNode.getView()
        );
        ArgumentNode mainConNexus
                = findNextNexus( conNode );
        ArgumentNode mainConConnector
                = mainConNexus.getParent();
        multiArgConnector.setParent( conNode
        );
        ListIterator<ArgumentNode> mainConConnectorIT
                = mainConConnector.getChildren().listIterator();
        while ( mainConConnectorIT.hasNext() )
        {
            ArgumentNode child = mainConConnectorIT.next();
            multiArgConnector.addAsChild( child );
            child.setParent( multiArgConnector );
            mainConConnectorIT.remove();
        }
        conNode.removeChild( mainConConnector );
        conNode.addAsChild( multiArgConnector );
        canvas.getChildren().remove(
                mainConConnector.getView()
        );
        canvas.getChildren().add( multiArgConnector.getView() );
        translateNode( mainConNexus,
                0, 205
        );
    }

    private ArgumentNode createMultiArgConnector( Node parentView )
    {
        Point2D layout = getRelativeLayout( parentView );
        MultiArgConnectionNode connector
                = new MultiArgConnectionNode( layout );

        return connector;
    }

    private void mergeMatrices(
            List<ArgumentNode> targetLayer,
            List<List<ArgumentNode>> targetNexus,
            List<List<ArgumentNode>> mergeNexus
    )
    {
        ListIterator<List<ArgumentNode>> layerIT
                = targetNexus.listIterator( targetNexus.indexOf( targetLayer ) );

        Iterator<List<ArgumentNode>> mergedTreeIt
                = mergeNexus.iterator();

        while ( mergedTreeIt.hasNext() )
        {
            if ( !layerIT.hasNext() )
            {
                List<ArgumentNode> newLayer = new ArrayList<>();
                for ( ArgumentNode nexus : mergedTreeIt.next() )
                {
                    newLayer.add( nexus );
                }
                layerIT.add( newLayer );
            } else
            {
                targetLayer = layerIT.next();
                for ( ArgumentNode nexus : mergedTreeIt.next() )
                {
                    targetLayer.add( nexus );
                }
            }
        }
    }

    private void updateNexusMatrixShiftForward(
            ArgumentNode parent,
            List<List<ArgumentNode>> matrix
    )
    {
        ListIterator<List<ArgumentNode>> layerIT
                = matrix.listIterator( matrix.size() );
        while ( layerIT.hasPrevious() )
        {
            List<ArgumentNode> tempList = new ArrayList<>();
            ListIterator<ArgumentNode> currentLayerIT
                    = layerIT.previous().listIterator();
            while ( currentLayerIT.hasNext() )
            {
                ArgumentNode currentNode = currentLayerIT.next();
                if ( containsNode( parent, currentNode ) )
                {
                    tempList.add( currentNode );
                    currentLayerIT.remove();
                }
            }

            if ( !tempList.isEmpty() )
            {
                layerIT.next();
                if ( !layerIT.hasNext() )
                {
                    layerIT.add( tempList );
                } else
                {
                    List<ArgumentNode> targetLayer = layerIT.next();
                    for ( ArgumentNode node : tempList )
                    {
                        targetLayer.add( node );
                    }
                }
                layerIT.previous();
                layerIT.previous();
            }

        }
    }

    public void detatchMultiArgument(
            MultiArgSubConclusionPaneController subArgControl,
            Point2D coords )
    {
        try
        {
            /*
             * get reference to the sub argument that is going to be split up
             * and its parent
             */
            ArgumentNode target
                    = searchForNode( root, subArgControl.getMainPane() );
            ArgumentNode targetConnector = target.getParent();
            ArgumentNode targetNexus = targetConnector.getParent();
            deleteCommentPane( target );
            ConclusionNode targetSharedConclusion
                    = ( ConclusionNode ) targetNexus.getParent().getParent();
            ConclusionPaneController targetConclusionControl
                    = targetSharedConclusion.getControl();

            List<ArgumentNode> targetLayer
                    = findMatrixLayer( target, paneMatrix );
            /*
             * Remove any shared counter arguments
             */
            List<CounterArgumentModel> counterArgs
                    = subArgControl
                            .getArgument()
                            .getConclusion()
                            .getCounterArgumentList();
            // remove conclusions model of argument being detached from any
            // counter arguments
            for ( CounterArgumentModel counter : counterArgs )
            {
                counter.removeFromParentModelList(
                        subArgControl.getArgument().getConclusion()
                );
            }
            // remove any counter arguments
            subArgControl
                    .getArgument()
                    .getConclusion()
                    .getCounterArgumentList()
                    .clear();

            /*
             * get the coordinates for where the new conclusion pane will be
             * drawn
             */
            Point2D targetCoords = new Point2D(
                    target.getView().getLayoutX() - 122,
                    target.getView().getLayoutY()
            );

            /*
             * remove sub arg from nexus children and shared argument list
             */
            ListIterator<ArgumentNode> childIT
                    = targetNexus.getChildren().listIterator();
            while ( childIT.hasNext() )
            {
                ArgumentNode child = childIT.next();
                if ( child.equals( targetConnector ) )
                {
                    childIT.remove();
                }
            }
            targetConclusionControl.removeArgument( subArgControl.getArgument() );
            canvas.getChildren().remove( target.getView() );
            canvas.getChildren().remove( targetConnector.getView() );
            removeNodeFromMatrix( paneMatrix, target );
            shrinkParentNexus( targetNexus );

            /*
             * create a new argument tree to contain the conclusion side of the
             * split
             */
            ArgumentViewTree newArgTree
                    = new ArgumentViewTree( canvas, canvasControl );

            /*
             * make a new conclusion node and attached the branch containing the
             * conclusion side of the chain node to it and draw it
             */
            ConclusionNode newConclusion
                    = createConclusionView(
                            subArgControl.getArgument(),
                            targetCoords
                    );
            newConclusion.getControl().setCertaintyController(
                    subArgControl.getCertaintyControl()
            );
            newConclusion.setArgTree( newArgTree );
            newArgTree.setRoot( newConclusion );

            ArgumentNode newConclusionConnect = createConclusionConnector(
                    newConclusion.getView()
            );
            ArgumentNode detachNexus
                    = findNextNexus( target );
            ArgumentNode detachConConnector
                    = detachNexus.getParent();
            newConclusionConnect.setParent(
                    target
            );
            translateNode( target,
                    20, 0
            );
            ListIterator<ArgumentNode> detachConConnectorIT
                    = detachConConnector.getChildren().listIterator();
            while ( detachConConnectorIT.hasNext() )
            {
                ArgumentNode child = detachConConnectorIT.next();
                newConclusionConnect.addAsChild( child );
                child.setParent( newConclusionConnect );
                detachConConnectorIT.remove();
            }
            target.removeChild( detachConConnector );
            target.addAsChild( newConclusionConnect );
            canvas.getChildren().remove(
                    detachConConnector.getView()
            );
            System.out.println( "here!!!!!" );
            canvas.getChildren().add( newConclusionConnect.getView() );
            translateNode( detachNexus,
                    0, -100
            );
            ListIterator<ArgumentNode> targetChildren
                    = target.getChildren().listIterator();
            while ( targetChildren.hasNext() )
            {
                ArgumentNode child = targetChildren.next();
                newConclusion.addAsChild( child );
                child.setParent( newConclusion );
                newArgTree.changeArgTree( child );
                targetChildren.remove();
            }
            canvas.getChildren().add( newConclusion.getView() );

            /*
             * shift the newly made argument tree so that it's offset from the
             * premise of the old tree
             */
            double transX = coords.getX() - target.getView().getLayoutX();
            double transY = coords.getY() - target.getView().getLayoutY();
            translateNode( newConclusion, transX, transY );
            for ( ArgumentNode node : newConclusion.getChildren() )
            {
                if ( node instanceof ArgumentCertaintyNode )
                {
                    node.getView().setLayoutX(
                            node.getView().getLayoutX() + 85
                    );
                    node.getView().setLayoutY(
                            node.getView().getLayoutY() + 105
                    );
                }/*
                 * if (node instanceof ArgumentSchemeLabel) {
                 * node.getView().setLayoutY(node.getView().getLayoutY() + 95);
                 * }
                 */
                if ( node instanceof CQConnectionNode
                        || node instanceof ArgumentSchemeLabel )
                {
                    translateNode( node, 0, -100 );
                }
            }

            /*
             * clean up chain pane and register the new tree with the
             * cinstruction area
             */
            canvas.getChildren().remove( target.getView() );
            canvasControl.registerNewArgTree( newArgTree );

            /*
             * update the matrices and adjust tree to accomodate new dimensions
             */
            targetLayer.add( newConclusion );
            updateMatrixOnDetach(
                    newArgTree,
                    paneMatrix,
                    newArgTree.getPaneMatrix()
            );
            updateMatrixOnDetach(
                    newArgTree,
                    nexusMatrix,
                    newArgTree.getNexusMatrix()
            );
            collisionAdjustment();

            /*
             * check if we need to remove the shared conclusion structure i.e.
             * if there is only 1 argument left in the structure
             */
            if ( targetNexus.getChildren().size() == 1 )
            {
                ArgumentNode multiNode = targetNexus.getParent().getParent();
                if ( multiNode.equals( root ) )
                {
                    convertToSingleArgumentConclusion(
                            root,
                            targetConclusionControl.getConclusionArgumentModel()
                    );
                } else
                {
                    if ( multiNode instanceof ChainNode )
                    {
                        convertToSingleArgumentChain( ( ChainNode ) multiNode );
                    }
                }
                collisionAdjustment();

            }
        } catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class
                    .getName() ).log( Level.SEVERE, null, ex );
        }
    }

    private void convertToSingleArgumentChain( ChainNode multiArgNode )
            throws IOException
    {
        MultiArgSubNode subArgumentNode
                = ( MultiArgSubNode ) findNextSubArgument( multiArgNode );
        List<ArgumentNode> targetLayer
                = findMatrixLayer( subArgumentNode, paneMatrix );
        /*
         * get the coordinates for where the new conclusion pane will be drawn
         */

        ChainNode newChain = createChainViewConclusion(
                multiArgNode.getParent(),
                subArgumentNode,
                multiArgNode.getControl()
        );

        newChain.setParent( multiArgNode.getParent() );
        multiArgNode.getParent().addAsChild( newChain );
        newChain.getParent().removeChild( multiArgNode );
        targetLayer.add( newChain );

        newChain.getControl().setCertaintyController(
                subArgumentNode.getControl().getCertaintyControl()
        );

        ArgumentNode newConclusionConnect = createConclusionConnector(
                subArgumentNode.getView()
        );

        ArgumentNode detachNexus
                = findNextNexus( subArgumentNode );
        ArgumentNode detachConConnector
                = detachNexus.getParent();
        newConclusionConnect.setParent(
                subArgumentNode
        );

        ListIterator<ArgumentNode> detachConConnectorIT
                = detachConConnector.getChildren().listIterator();
        while ( detachConConnectorIT.hasNext() )
        {
            ArgumentNode child = detachConConnectorIT.next();
            newConclusionConnect.addAsChild( child );
            child.setParent( newConclusionConnect );
            detachConConnectorIT.remove();
        }
        subArgumentNode.removeChild( detachConConnector );
        subArgumentNode.addAsChild( newConclusionConnect );
        canvas.getChildren().remove(
                detachConConnector.getView()
        );
        canvas.getChildren().add( newConclusionConnect.getView() );

        translateNode( detachNexus,
                0, -205
        );

        ListIterator<ArgumentNode> subArgumentChildren
                = subArgumentNode.getChildren().listIterator();
        while ( subArgumentChildren.hasNext() )
        {
            ArgumentNode child = subArgumentChildren.next();
            newChain.addAsChild( child );
            child.setParent( newChain );
            subArgumentChildren.remove();
        }

        double transY
                = newChain.getView().getBoundsInParent().getMaxY()
                - newConclusionConnect.getView().getBoundsInParent().getMinY();
        canvas.getChildren().add( newChain.getView() );
        removeNodeFromMatrix( paneMatrix, multiArgNode );
        removeNodeFromMatrix( paneMatrix, subArgumentNode );
        removeNodeFromMatrix( nexusMatrix, findNextNexus( multiArgNode ) );
        updateNexusMatrixShiftBack( paneMatrix, newChain );
        updateNexusMatrixShiftBack( nexusMatrix, newChain );

        ArgumentNode counterConnection
                = findChildCounterConnection( multiArgNode );
        if ( counterConnection != null )
        {
            newChain.addAsChild( counterConnection );
            counterConnection.getParent().removeChild( counterConnection );
            counterConnection.setParent( newChain );
        }

        undrawTree( multiArgNode );

        for ( ArgumentNode node : newChain.getChildren() )
        {
            translateNode( node, 0, transY );
            if ( node instanceof ArgumentCertaintyNode )
            {
                node.getView().setLayoutX( node.getView().getLayoutX() + 85 );
            }
            if ( node instanceof CQConnectionNode
                    || node instanceof ArgumentSchemeLabel )
            {
                translateNode( node, 0, -205 );
            }
            node.getView().toFront();
        }
        if ( counterConnection != null )
        {
            translateNode( counterConnection, 0, -transY );
        }
    }

    private void updateNexusMatrixShiftBack(
            List<List<ArgumentNode>> matrix,
            ArgumentNode parent
    )
    {
        ListIterator<List<ArgumentNode>> layerIT = matrix.listIterator();
        while ( layerIT.hasNext() )
        {
            List<ArgumentNode> tempList = new ArrayList<>();
            ListIterator<ArgumentNode> currentLayerIT
                    = layerIT.next().listIterator();
            while ( currentLayerIT.hasNext() )
            {
                ArgumentNode currentNode = currentLayerIT.next();
                if ( containsNode( parent, currentNode ) )
                {
                    tempList.add( currentNode );
                    currentLayerIT.remove();
                }
            }

            if ( !tempList.isEmpty() )
            {
                layerIT.previous();
                if ( !layerIT.hasPrevious() )
                {
                    layerIT.add( tempList );
                } else
                {
                    List<ArgumentNode> targetLayer = layerIT.previous();
                    for ( ArgumentNode node : tempList )
                    {
                        targetLayer.add( node );
                    }
                    layerIT.next();
                }
                layerIT.next();
            }
        }

        List<ArgumentNode> finalLayer = layerIT.previous();
        if ( finalLayer.isEmpty() )
        {
            layerIT.remove();
        }
    }

    private ChainNode createChainViewConclusion(
            ArgumentNode parentNode,
            MultiArgSubNode subNode,
            ChainPaneController multiControl )
            throws IOException
    {
        ChainPaneController chainControl = generateChainNode();
        if ( multiControl.getCQFlag() )
        {
            chainControl.setCQFlag();
            chainControl.setConnector( multiControl.getConnector() );
        }
        if ( multiControl.getCounterFlag() )
        {
            chainControl.setCounterFlag();
            chainControl.setConnector( multiControl.getConnector() );
        }
        chainControl.addConclusionArgumentModel(
                multiControl.getConclusionArgumentModel()
        );
        chainControl.addPremiseArgument( multiControl.getPremiseArgument() );
        chainControl.setArgumentViewTree( this );
        chainControl.setParentControl( canvasControl );
        chainControl.setCertaintyController(
                subNode.getControl().getCertaintyControl()
        );
        chainControl.setPosition( multiControl.getPosition() );

        chainControl.setPropositionModel(
                multiControl.getConclusionArgumentModel().getConclusion().getProposition()
        );

        Point2D layout = getRelativeLayout( parentNode.getView() );
        Point2D adjustedLayout;
        if ( chainControl.getCQFlag() )
        {
            adjustedLayout
                    = new Point2D(
                            ( int ) layout.getX()
                            + chainControl.getConnector().getWidth()
                            - 163,
                            ( int ) layout.getY() + 15
                    );
        } else if ( chainControl.getCounterFlag() )
        {
            adjustedLayout
                    = new Point2D(
                            ( int ) layout.getX()
                            + chainControl.getConnector().getWidth(),
                            ( int ) layout.getY() - 145
                    );
        } else
        {
            adjustedLayout = new Point2D(
                    ( int ) ( layout.getX() - PREMISE_WIDTH / 2 ),
                    ( int ) layout.getY()
            );
        }

        LayoutUtils.setChildLayout( chainControl.getMainPane(), adjustedLayout );
        return new ChainNode( chainControl.getMainPane(), chainControl );
    }

    private boolean removeNodeFromMatrix(
            List<List<ArgumentNode>> matrix,
            ArgumentNode target
    )
    {
        ListIterator<List<ArgumentNode>> layerIT
                = matrix.listIterator();
        boolean targetRemoved = false;
        while ( layerIT.hasNext() && targetRemoved == false )
        {
            List<ArgumentNode> currentLayer = layerIT.next();
            ListIterator<ArgumentNode> nodeIT
                    = currentLayer.listIterator();
            while ( nodeIT.hasNext() && targetRemoved == false )
            {
                ArgumentNode currentNode = nodeIT.next();
                if ( currentNode.equals( target ) )
                {
                    nodeIT.remove();
                    targetRemoved = true;
                }
            }
        }
        return targetRemoved;
    }

    private void convertToSingleArgumentConclusion(
            ConclusionNode multiArgConNode,
            ArgumentModel argument
    ) throws IOException
    {
        MultiArgSubNode subArgumentNode
                = ( MultiArgSubNode ) findNextSubArgument( root );
        List<ArgumentNode> targetLayer
                = findMatrixLayer( subArgumentNode, paneMatrix );

        /*
         * get the coordinates for where the new conclusion pane will be drawn
         */
        Point2D targetCoords = new Point2D(
                multiArgConNode.getView().getLayoutX(),
                multiArgConNode.getView().getLayoutY()
        );

        ConclusionNode newConclusion = createConclusionView(
                argument, targetCoords
        );
        targetLayer.add( newConclusion );
        newConclusion.getControl().setCertaintyController(
                subArgumentNode.getControl().getCertaintyControl()
        );

        ArgumentNode newConclusionConnect = createConclusionConnector(
                subArgumentNode.getView()
        );
        ArgumentNode detachNexus
                = findNextNexus( subArgumentNode );
        ArgumentNode detachConConnector
                = detachNexus.getParent();
        newConclusionConnect.setParent(
                subArgumentNode
        );

        ListIterator<ArgumentNode> detachConConnectorIT
                = detachConConnector.getChildren().listIterator();
        while ( detachConConnectorIT.hasNext() )
        {
            ArgumentNode child = detachConConnectorIT.next();
            newConclusionConnect.addAsChild( child );
            child.setParent( newConclusionConnect );
            detachConConnectorIT.remove();
        }
        subArgumentNode.removeChild( detachConConnector );
        subArgumentNode.addAsChild( newConclusionConnect );
        canvas.getChildren().remove(
                detachConConnector.getView()
        );
        canvas.getChildren().add( newConclusionConnect.getView() );
        translateNode( newConclusionConnect,
                0, 105
        );
        translateNode( detachNexus,
                0, -205
        );

        ListIterator<ArgumentNode> subArgumentChildren
                = subArgumentNode.getChildren().listIterator();
        while ( subArgumentChildren.hasNext() )
        {
            ArgumentNode child = subArgumentChildren.next();
            newConclusion.addAsChild( child );
            child.setParent( newConclusion );
            subArgumentChildren.remove();
        }

        double transY
                = targetCoords.getY()
                - subArgumentNode.getView().getBoundsInParent().getMinY();
        canvas.getChildren().add( newConclusion.getView() );

        removeNodeFromMatrix( paneMatrix, multiArgConNode );
        removeNodeFromMatrix( paneMatrix, subArgumentNode );
        removeNodeFromMatrix( nexusMatrix, findNextNexus( multiArgConNode ) );

        updateNexusMatrixShiftBack( paneMatrix, newConclusion );
        updateNexusMatrixShiftBack( nexusMatrix, newConclusion );

        ArgumentNode counterConnection
                = findChildCounterConnection( multiArgConNode );
        if ( counterConnection != null )
        {
            newConclusion.addAsChild( counterConnection );
            counterConnection.getParent().removeChild( counterConnection );
            counterConnection.setParent( newConclusion );
        }

        undrawTree( root );
        root = newConclusion;

        for ( ArgumentNode node : newConclusion.getChildren() )
        {
            translateNode( node, 0, transY );
            if ( node instanceof ArgumentCertaintyNode )
            {
                node.getView().setLayoutX( node.getView().getLayoutX() + 85 );
                node.getView().setLayoutY( node.getView().getLayoutY() + 105 );
            }
            if ( node instanceof CQConnectionNode
                    || node instanceof ArgumentSchemeLabel )
            {
                translateNode( node, 0, -100 );
            }
        }
        if ( counterConnection != null )
        {
            translateNode( counterConnection, 0, -transY );
        }
    }

    private ArgumentNode findChildCounterConnection( ArgumentNode target )
    {
        ArgumentNode result = null;
        for ( ArgumentNode child : target.getChildren() )
        {
            if ( child instanceof CounterArgumentConnectionNode )
            {
                result = child;
            }
        }
        return result;
    }

    private void undrawTree( ArgumentNode node )
    {
        canvas.getChildren().remove( node.getView() );
        for ( ArgumentNode child : node.getChildren() )
        {
            undrawTree( child );
        }
    }

    private ArgumentNode findNextSubArgument( ArgumentNode node )
    {
        if ( node instanceof MultiArgSubNode )
        {
            return node;
        }

        ArgumentNode target = null;
        for ( int i = 0; target == null && i < node.getChildren().size(); i++ )
        {
            target = findNextSubArgument( node.getChildren().get( i ) );
        }

        return target;
    }

    public void addSupportToArgument( String mergedTreeID,
            MultiArgConclusionPaneController multiArgControl
    ) throws IOException
    {
        ArgumentViewTree mergedTree = canvasControl.getArgTree( mergedTreeID );
        if ( mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController )
        {
            addMultiConclusionSupport( mergedTree, multiArgControl );
        } else
        {
            addSingleConclusionSupport( mergedTree, multiArgControl );
        }

    }

    public void addSupportToArgument(
            String mergedTreeID,
            MultiArgChainPaneController multiArgControl
    ) throws IOException
    {
        ArgumentViewTree mergedTree = canvasControl.getArgTree( mergedTreeID );
        if ( mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController )
        {
            addMultiConclusionSupport( mergedTree, multiArgControl );
        } else
        {
            addSingleConclusionSupport( mergedTree, multiArgControl );
        }

    }

    private void addMultiConclusionSupport(
            ArgumentViewTree mergedTree,
            MultiArgConclusionPaneController multiArgControl
    ) throws IOException
    {
        ArgumentNode target
                = searchForNode( root, multiArgControl.getMainPane() );
        PremiseNexusNode targetNexus = ( PremiseNexusNode ) findNextNexus( target );
        // gets the nexus layer below the one containing the target nexus
        List<ArgumentNode> targetPaneMatrixLayer
                = paneMatrix.get(
                        paneMatrix.indexOf(
                                findMatrixLayer( target, paneMatrix )
                        )
                        + 1
                );
        List<ArgumentNode> targetNexusMatrixLayer
                = nexusMatrix.get(
                        nexusMatrix.indexOf(
                                findMatrixLayer(
                                        findNextNexus( target ),
                                        nexusMatrix
                                )
                        )
                        + 1
                );
        ArgumentNode mergedRoot = mergedTree.getRoot();
        ArgumentNode mergedNexus = findNextNexus( mergedRoot );

        List<MultiArgSubNode> mergeSubNodeList = new ArrayList<>();

        ListIterator<ArgumentNode> mergedNexusIT
                = mergedNexus.getChildren().listIterator();
        while ( mergedNexusIT.hasNext() )
        {
            ArgumentNode childNode = mergedNexusIT.next();
            MultiArgSubNode subNode = findNextSubArgNode( childNode );
            mergeSubNodeList.add( subNode );
            subNode.getControl()
                    .getArgument()
                    .setConclusion(
                            multiArgControl.getProposition()
                    );

            multiArgControl.addConclusionArgumentModel(
                    subNode.getControl().getArgument()
            );

            targetNexus.addAsChild( childNode );
            childNode.setParent( targetNexus );
            mergedNexusIT.remove();

            double amountShrunk = resizeNexusToDefault( targetNexus );
            /*
             * shift node so that it is centered relative to its parent
             */
            targetNexus.getView().setLayoutX(
                    targetNexus.getView().getLayoutX()
                    + ( amountShrunk / 2 )
            );
            /*
             * reposition subtrees of nexus so that they are in the correct
             * relative positions
             */
            shiftNexusChildrenOnDetach( targetNexus );
        }

        /*
         * have to skip the first layer of the merged tree's nexus so that the
         * nexus controlling the supporting sup-arguments doesn't get copied
         */
        mergeMatrices(
                targetPaneMatrixLayer,
                paneMatrix,
                mergedTree.paneMatrix.subList( 1, mergedTree.paneMatrix.size() )
        );
        mergeMatrices(
                targetNexusMatrixLayer,
                nexusMatrix,
                mergedTree.nexusMatrix.subList( 1, mergedTree.nexusMatrix.size() )
        );

        mergeCounterArguments(
                target,
                mergedRoot,
                multiArgControl,
                mergeSubNodeList
        );

        changeArgTree( root );
        canvasControl.removeArgumentTree( mergedTree.getTreeID() );
        undrawTree( mergedRoot );
        collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();
    }

    private void addMultiConclusionSupport(
            ArgumentViewTree mergedTree,
            MultiArgChainPaneController multiArgControl
    ) throws IOException
    {
        ArgumentNode target
                = searchForNode( root, multiArgControl.getMainPane() );
        PremiseNexusNode targetNexus = ( PremiseNexusNode ) findNextNexus( target );
        // gets the nexus layer below the one containing the target nexus
        List<ArgumentNode> targetPaneMatrixLayer
                = paneMatrix.get(
                        paneMatrix.indexOf(
                                findMatrixLayer( target, paneMatrix )
                        )
                        + 1
                );
        List<ArgumentNode> targetNexusMatrixLayer
                = nexusMatrix.get(
                        nexusMatrix.indexOf(
                                findMatrixLayer(
                                        findNextNexus( target ),
                                        nexusMatrix
                                )
                        )
                        + 1
                );
        ArgumentNode mergedRoot = mergedTree.getRoot();
        ArgumentNode mergedNexus = findNextNexus( mergedRoot );

        List<MultiArgSubNode> mergeSubNodeList = new ArrayList<>();

        ListIterator<ArgumentNode> mergedNexusIT
                = mergedNexus.getChildren().listIterator();
        while ( mergedNexusIT.hasNext() )
        {
            ArgumentNode childNode = mergedNexusIT.next();
            MultiArgSubNode subNode = findNextSubArgNode( childNode );
            mergeSubNodeList.add( subNode );
            subNode.getControl()
                    .getArgument()
                    .setConclusion(
                            multiArgControl.getProposition()
                    );

            multiArgControl.addConclusionArgumentModel(
                    subNode.getControl().getArgument()
            );

            targetNexus.addAsChild( childNode );
            childNode.setParent( targetNexus );
            mergedNexusIT.remove();

            double amountShrunk = resizeNexusToDefault( targetNexus );
            /*
             * shift node so that it is centered relative to its parent
             */
            targetNexus.getView().setLayoutX(
                    targetNexus.getView().getLayoutX()
                    + ( amountShrunk / 2 )
            );
            /*
             * reposition subtrees of nexus so that they are in the correct
             * relative positions
             */
            shiftNexusChildrenOnDetach( targetNexus );
        }

        /*
         * have to skip the first layer of the merged tree's nexus so that the
         * nexus controlling the supporting sup-arguments doesn't get copied
         */
        mergeMatrices( targetPaneMatrixLayer,
                paneMatrix,
                mergedTree.paneMatrix.subList( 1, mergedTree.paneMatrix.size() )
        );
        mergeMatrices(
                targetNexusMatrixLayer,
                nexusMatrix,
                mergedTree.nexusMatrix.subList( 1, mergedTree.nexusMatrix.size() )
        );

        mergeCounterArguments(
                target,
                mergedRoot,
                multiArgControl,
                mergeSubNodeList
        );
        changeArgTree( root );
        canvasControl.removeArgumentTree( mergedTree.getTreeID() );
        undrawTree( mergedRoot );
        collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();

    }

    private void mergeCounterArguments(
            ArgumentNode parentNode,
            ArgumentNode mergeNode,
            ConclusionPaneController parentController,
            List<MultiArgSubNode> subNodeList
    ) throws IOException
    {
        List<ArgumentModel> conclusionList
                = parentController.getConclusionArgumentModelList();
        // all sub nodes should have identical counter argument lists, so we
        // only need to check the first one
        PremiseModel firstSubNodeConclusion
                = subNodeList.get( 0 )
                        .getControl()
                        .getArgument()
                        .getConclusion();
        PremiseModel firstMultiArgConclusion
                = conclusionList.get( 0 ).getConclusion();
        PremiseNexusNode nexus = null;
        if ( firstMultiArgConclusion.hasCounterArgument() )
        {
            for ( ArgumentNode node : parentNode.getChildren() )
            {
                if ( node instanceof CounterArgumentConnectionNode )
                {
                    nexus = ( PremiseNexusNode ) findNextNexus( node );
                }
            }
        }
        if ( firstSubNodeConclusion.hasCounterArgument() )
        {
            // create counter argumnet structure if necessary
            // again, we only need to check the first counter arg list
            if ( !firstMultiArgConclusion.hasCounterArgument() )
            {
                /*
                 * create new counter arg structure for the multi-arg structure
                 */
                // create the connector for the coutner arg structure
                ArgumentNode counterConnector
                        = createCounterArgumentConnection( parentNode.getView() );
                parentNode.addAsChild( counterConnector );
                counterConnector.setParent( parentNode );
                canvas.getChildren().add( counterConnector.getView() );

                // create shield icon
                ArgumentNode counterIcon = createCounterIcon( counterConnector );
                counterIcon.setParent( counterConnector );
                counterConnector.addAsChild( counterIcon );
                canvas.getChildren().add( counterIcon.getView() );
                // add new counter icon to matrix
                paneMatrix
                        .get(
                                paneMatrix.indexOf(
                                        findMatrixLayer( parentNode, paneMatrix )
                                )
                        )
                        .add( counterIcon );

                // create the connector between the shield and the counter arg nexus
                ArgumentNode counterSecondaryConnector
                        = createPremiseConnection( counterIcon.getView(), 0 );
                counterIcon.addAsChild( counterSecondaryConnector );
                counterSecondaryConnector.setParent( counterIcon );
                canvas.getChildren().add( counterSecondaryConnector.getView() );
                translateNode( counterSecondaryConnector, 60, 0 );

                // create counter arg nexus
                nexus = ( PremiseNexusNode ) createNexus(
                        1,
                        counterSecondaryConnector.getView()
                );
                counterSecondaryConnector.addAsChild( nexus );
                nexus.setParent( counterSecondaryConnector );
                canvas.getChildren().add( nexus.getView() );
                nexusMatrix
                        .get(
                                nexusMatrix.indexOf(
                                        findMatrixLayer(
                                                findNextNexus( parentNode ),
                                                nexusMatrix
                                        )
                                )
                        )
                        .add( nexus );
            } else
            {
                // if the multiArg pane already has counter args, get reference 
                // to the nexus for them
                for ( ArgumentNode node : parentNode.getChildren() )
                {
                    if ( node instanceof CounterArgumentConnectionNode )
                    {
                        nexus = ( PremiseNexusNode ) findNextNexus( node );
                    }
                }
            }

            // find specific counter argument connections for mainConNode counters
            ArgumentNode counterConnectionNode = null;
            for ( ArgumentNode child : mergeNode.getChildren() )
            {
                if ( child instanceof CounterArgumentConnectionNode )
                {
                    counterConnectionNode = child;
                }
            }
            ListIterator<ArgumentNode> mainConSpecificCounterConnectors
                    = findNextNexus( counterConnectionNode ).getChildren().listIterator();
            //translate counter arguments and reassign parents/children
            while ( mainConSpecificCounterConnectors.hasNext() )
            {
                ArgumentNode connector = mainConSpecificCounterConnectors.next();

                Point2D layout = getRelativeLayout( nexus.getView() );
                Point2D adjustedLayout = new Point2D(
                        layout.getX() - nexus.getView().getBoundsInParent().getWidth() / 2,
                        layout.getY()
                );
                translateNode( connector,
                        adjustedLayout.getX() - connector.getView().getLayoutX(),
                        adjustedLayout.getY() - connector.getView().getLayoutY()
                );

                // reassigne relations
                nexus.addAsChild( connector );
                mainConSpecificCounterConnectors.remove();
                connector.setParent( nexus );

                // update matrix
                //shiftCounterArgumentInMatrix(
                //connector, targetLayerIndex
                //);
                // adjust nexus size
                double amountShrunk = resizeNexusToDefault( nexus );
                /*
                 * shift node so that it is centered relative to its parent
                 */
                nexus.getView().setLayoutX(
                        nexus.getView().getLayoutX()
                        + ( amountShrunk / 2 )
                );
                /*
                 * reposition subtrees of nexus so that they are in the correct
                 * relative positions
                 */
                shiftNexusChildrenOnDetach( nexus );
            }
        }

        // gather counter arguments
        List<CounterArgumentModel> consolidatedCounterArguments
                = new ArrayList<>();
        // becuase all conclusions should have identical counter arg lists,
        // we only consolidate the counter args for the first conclusions.
        for ( CounterArgumentModel counterArg
                : firstSubNodeConclusion.getCounterArgumentList() )
        {
            consolidatedCounterArguments.add( counterArg );
        }
        for ( CounterArgumentModel counterArg
                : firstMultiArgConclusion.getCounterArgumentList() )
        {
            consolidatedCounterArguments.add( counterArg );
        }
        for ( ArgumentModel conclusionArg : conclusionList )
        {
            conclusionArg.getConclusion().getCounterArgumentList().clear();
            conclusionArg.getConclusion().getCounterArgumentList().addAll(
                    consolidatedCounterArguments
            );
        }

        // walk through all counter panes and update the parent model list to
        // include all sub args
        if ( nexus != null )
        {
            for ( ArgumentNode child : nexus.getChildren() )
            {
                for ( ArgumentNode nexusChild : child.getChildren() )
                {
                    if ( nexusChild instanceof CounterArgumentNode )
                    {
                        List<PremiseModel> conModelList = new ArrayList<>();
                        for ( ArgumentModel conclusionArg : conclusionList )
                        {
                            conModelList.add( conclusionArg.getConclusion() );
                        }
                        ( ( CounterArgumentNode ) nexusChild ).getControl().setParentModelList( conModelList );
                    }
                    if ( nexusChild instanceof CounterPropositionNode )
                    {
                        List<PremiseModel> conModelList = new ArrayList<>();
                        for ( ArgumentModel conclusionArg : conclusionList )
                        {
                            conModelList.add( conclusionArg.getConclusion() );
                        }
                        ( ( CounterPropositionNode ) nexusChild ).getControl().setParentModelList( conModelList );
                    }
                }
            }
        }
        collisionAdjustment();
    }

    private void addSingleConclusionSupport(
            ArgumentViewTree mergedTree,
            MultiArgChainPaneController multiArgControl
    ) throws IOException
    {
        ArgumentNode target
                = searchForNode( root, multiArgControl.getMainPane() );
        PremiseNexusNode targetNexus = ( PremiseNexusNode ) findNextNexus( target );
        // gets the nexus layer below the one containing the target nexus
        List<ArgumentNode> targetMatrixLayer
                = paneMatrix.get(
                        paneMatrix.indexOf(
                                findMatrixLayer( target, paneMatrix )
                        )
                        + 1
                );
        ArgumentNode mergedRoot = mergedTree.getRoot();
        ConclusionPaneController mergedControl
                = mergedTree.getRoot().getControl();
        ArgumentModel argument = mergedControl.getConclusionArgumentModel();

        argument.setConclusion( multiArgControl.getProposition() );
        multiArgControl.addConclusionArgumentModel( argument );
        int position = multiArgControl.getConclusionArgumentModelList().size() - 1;
        ArgumentNode connection = createMultiArgPremiseConnection(
                targetNexus.getView(),
                position
        );
        targetNexus.addAsChild( connection );
        connection.setParent( targetNexus );
        canvas.getChildren().add( connection.getView() );

        MultiArgSubNode subArgumentConclusion
                = ( MultiArgSubNode ) createMultiArgSubView(
                        argument,
                        connection.getView(),
                        mergedControl.getCertaintyController(),
                        position
                );
        connection.addAsChild( subArgumentConclusion );
        subArgumentConclusion.setParent( connection );
        canvas.getChildren().add( subArgumentConclusion.getView() );

        replaceConnectorWithMultiArgConnector( mergedRoot );

        mergedTree.translateTree( subArgumentConclusion
                .getView()
                .getBoundsInParent()
                .getMinX()
                - ( ( PREMISE_WIDTH - 40 ) / 2 ),
                subArgumentConclusion.getView()
                        .getBoundsInParent()
                        .getMinY()
                - ( PREMISE_HEIGHT - 40 )
        );
        ListIterator<ArgumentNode> mergeConChildrenIT
                = mergedTree.getRoot().getChildren().listIterator();
        while ( mergeConChildrenIT.hasNext() )
        {
            ArgumentNode child = mergeConChildrenIT.next();
            subArgumentConclusion.addAsChild( child );
            child.setParent( subArgumentConclusion );
            mergeConChildrenIT.remove();
        }
        for ( ArgumentNode node : subArgumentConclusion.getChildren() )
        {
            if ( node instanceof ArgumentCertaintyNode )
            {
                node.getView().setLayoutX( node.getView().getLayoutX() - 85 );
            }
            if ( node instanceof CQConnectionNode
                    || node instanceof ArgumentSchemeLabel )
            {
                translateNode( node, 0, 205 );
            }
        }
        mergedTree.replaceInPaneMatrix( mergedTree.getRoot(), subArgumentConclusion );
        changeArgTree( root );
        canvasControl.removeArgumentTree( mergedTree.getTreeID() );
        canvas.getChildren().remove( mergedRoot.getView() );

        double amountShrunk = resizeNexusToDefault( targetNexus );
        /*
         * shift node so that it is centered relative to its parent
         */
        targetNexus.getView().setLayoutX(
                targetNexus.getView().getLayoutX()
                + ( amountShrunk / 2 )
        );
        /*
         * reposition subtrees of nexus so that they are in the correct relative
         * positions
         */
        shiftNexusChildrenOnDetach( targetNexus );

        mergeMatrices( targetMatrixLayer, paneMatrix, mergedTree.paneMatrix );

        mergeCounterArguments( ( ConclusionNode ) target, subArgumentConclusion );

        collisionAdjustment();

        canvasControl.constructionAreaSizeCheck();
    }

    private MultiArgSubNode findNextSubArgNode( ArgumentNode node )
    {
        if ( node instanceof MultiArgSubNode )
        {
            return ( MultiArgSubNode ) node;
        }

        MultiArgSubNode target = null;
        for ( int i = 0; target == null && i < node.getChildren().size(); i++ )
        {
            target = findNextSubArgNode( node.getChildren().get( i ) );
        }
        return target;
    }

    private void addSingleConclusionSupport(
            ArgumentViewTree mergedTree,
            MultiArgConclusionPaneController multiArgControl
    ) throws IOException
    {
        ArgumentNode target
                = searchForNode( root, multiArgControl.getMainPane() );
        PremiseNexusNode targetNexus = ( PremiseNexusNode ) findNextNexus( target );
        // gets the nexus layer below the one containing the target nexus
        List<ArgumentNode> targetMatrixLayer
                = paneMatrix.get(
                        paneMatrix.indexOf(
                                findMatrixLayer( target, paneMatrix )
                        )
                        + 1
                );
        ArgumentNode mergedRoot = mergedTree.getRoot();
        ConclusionPaneController mergedControl
                = mergedTree.getRoot().getControl();
        ArgumentModel argument = mergedControl.getConclusionArgumentModel();

        multiArgControl.addConclusionArgumentModel( argument );
        int position = multiArgControl.getConclusionArgumentModelList().size() - 1;
        ArgumentNode connection = createMultiArgPremiseConnection(
                targetNexus.getView(),
                position
        );
        targetNexus.addAsChild( connection );
        connection.setParent( targetNexus );
        canvas.getChildren().add( connection.getView() );

        MultiArgSubNode subArgumentConclusion
                = ( MultiArgSubNode ) createMultiArgSubView(
                        argument,
                        connection.getView(),
                        mergedControl.getCertaintyController(),
                        position
                );
        connection.addAsChild( subArgumentConclusion );
        subArgumentConclusion.setParent( connection );
        canvas.getChildren().add( subArgumentConclusion.getView() );

        replaceConnectorWithMultiArgConnector( mergedRoot );

        mergedTree.translateTree( subArgumentConclusion
                .getView()
                .getBoundsInParent()
                .getMinX()
                - ( ( PREMISE_WIDTH - 40 ) / 2 ),
                subArgumentConclusion.getView()
                        .getBoundsInParent()
                        .getMinY()
                - ( PREMISE_HEIGHT - 40 )
        );
        ListIterator<ArgumentNode> mergeConChildrenIT
                = mergedTree.getRoot().getChildren().listIterator();
        while ( mergeConChildrenIT.hasNext() )
        {
            ArgumentNode child = mergeConChildrenIT.next();
            subArgumentConclusion.addAsChild( child );
            child.setParent( subArgumentConclusion );
            mergeConChildrenIT.remove();
        }
        for ( ArgumentNode node : subArgumentConclusion.getChildren() )
        {
            if ( node instanceof ArgumentCertaintyNode )
            {
                node.getView().setLayoutX( node.getView().getLayoutX() - 85 );
            }
            if ( node instanceof CQConnectionNode
                    || node instanceof ArgumentSchemeLabel )
            {
                translateNode( node, 0, 205 );
            }
        }
        mergedTree.replaceInPaneMatrix( mergedTree.getRoot(), subArgumentConclusion );

        changeArgTree( root );
        canvasControl.removeArgumentTree( mergedTree.getTreeID() );
        canvas.getChildren().remove( mergedRoot.getView() );

        double amountShrunk = resizeNexusToDefault( targetNexus );
        /*
         * shift node so that it is centered relative to its parent
         */
        targetNexus.getView().setLayoutX(
                targetNexus.getView().getLayoutX()
                + ( amountShrunk / 2 )
        );
        /*
         * reposition subtrees of nexus so that they are in the correct relative
         * positions
         */
        shiftNexusChildrenOnDetach( targetNexus );

        mergeMatrices( targetMatrixLayer, paneMatrix, mergedTree.paneMatrix );

        mergeCounterArguments( ( ConclusionNode ) target, subArgumentConclusion );

        collisionAdjustment();

        canvasControl.constructionAreaSizeCheck();
    }

    private void mergeCounterArguments(
            ConclusionNode parentNode,
            MultiArgSubNode subNode
    ) throws IOException
    {
        ConclusionPaneController parentController
                = parentNode.getControl();
        List<ArgumentModel> argumentList
                = parentController.getConclusionArgumentModelList();
        MultiArgSubConclusionPaneController subControl
                = subNode.getControl();

        if ( subControl.getArgument().getConclusion().hasCounterArgument() )
        {
            // gather counter arguments
            List<CounterArgumentModel> consolidatedCounterArguments = new ArrayList<>();
            for ( ArgumentModel conclusionModel : argumentList )
            {
                // temp reference to counter arg list for this conclusion
                List<CounterArgumentModel> currentCounterArguments
                        = conclusionModel.getConclusion().getCounterArgumentList();
                //transfer over counter arguments to consolidated list
                for ( CounterArgumentModel counterArg : currentCounterArguments )
                {
                    consolidatedCounterArguments.add( counterArg );
                }
            }
            // create counter argumnet structure if necessary
            PremiseNexusNode nexus = null;
            ArgumentNode counterConnectionNode = null;
            for ( ArgumentNode child : parentNode.getChildren() )
            {
                if ( child instanceof CounterArgumentConnectionNode )
                {
                    counterConnectionNode = child;
                }
            }
            if ( counterConnectionNode == null )
            {
                /*
                 * create new counter arg structure for the multi-arg structure
                 */
                // create the connector for the coutner arg structure
                ArgumentNode counterConnector
                        = createCounterArgumentConnection( parentNode.getView() );
                parentNode.addAsChild( counterConnector );
                counterConnector.setParent( parentNode );
                canvas.getChildren().add( counterConnector.getView() );

                // create shield icon
                ArgumentNode counterIcon = createCounterIcon( counterConnector );
                counterIcon.setParent( counterConnector );
                counterConnector.addAsChild( counterIcon );
                canvas.getChildren().add( counterIcon.getView() );
                // add new counter icon to matrix
                paneMatrix
                        .get(
                                paneMatrix.indexOf(
                                        findMatrixLayer( parentNode, paneMatrix )
                                )
                        )
                        .add( counterIcon );

                // create the connector between the shield and the counter arg nexus
                ArgumentNode counterSecondaryConnector
                        = createPremiseConnection( counterIcon.getView(), 0 );
                counterIcon.addAsChild( counterSecondaryConnector );
                counterSecondaryConnector.setParent( counterIcon );
                canvas.getChildren().add( counterSecondaryConnector.getView() );
                translateNode( counterSecondaryConnector, 60, 0 );

                // create counter arg nexus
                nexus = ( PremiseNexusNode ) createNexus(
                        1,
                        counterSecondaryConnector.getView()
                );
                counterSecondaryConnector.addAsChild( nexus );
                nexus.setParent( counterSecondaryConnector );
                canvas.getChildren().add( nexus.getView() );
            } else
            {
                // if the multiArg pane already has counter args, get reference 
                // to the nexus for them
                for ( ArgumentNode node : parentNode.getChildren() )
                {
                    if ( node instanceof CounterArgumentConnectionNode )
                    {
                        nexus = ( PremiseNexusNode ) findNextNexus( node );
                    }
                }
            }

            int targetLayerIndex
                    = paneMatrix.indexOf(
                            findMatrixLayer( parentNode, paneMatrix )
                    )
                    + 1;
            int targetNexusLayerIndex
                    = nexusMatrix.indexOf(
                            findMatrixLayer(
                                    findNextNexus( parentNode ),
                                    paneMatrix
                            )
                    ) + 1;

            // find specific counter argument connections for mainConNode counters
            ArgumentNode subCounterConnectionNode = null;
            for ( ArgumentNode child : subNode.getChildren() )
            {
                if ( child instanceof CounterArgumentConnectionNode )
                {
                    subCounterConnectionNode = child;
                }
            }
            if ( subCounterConnectionNode != null )
            {
                // remove counter icon from matrix
                removeNodeFromMatrix(
                        paneMatrix,
                        subCounterConnectionNode.getChildren().get( 0 )
                );

                ListIterator<ArgumentNode> mainConSpecificCounterConnectors
                        = findNextNexus( subCounterConnectionNode ).getChildren().listIterator();
                //translate counter arguments and reassign parents/children
                while ( mainConSpecificCounterConnectors.hasNext() )
                {
                    ArgumentNode connector = mainConSpecificCounterConnectors.next();

                    Point2D layout = getRelativeLayout( nexus.getView() );
                    Point2D adjustedLayout = new Point2D(
                            layout.getX() - nexus.getView().getBoundsInParent().getWidth() / 2,
                            layout.getY()
                    );
                    translateNode( connector,
                            adjustedLayout.getX() - connector.getView().getLayoutX(),
                            adjustedLayout.getY() - connector.getView().getLayoutY()
                    );

                    // reassigne relations
                    nexus.addAsChild( connector );
                    mainConSpecificCounterConnectors.remove();
                    connector.setParent( nexus );

                    // update matrix
                    shiftCounterArgumentInMatrix(
                            paneMatrix,
                            connector,
                            targetLayerIndex
                    );
                    shiftCounterArgumentInMatrix(
                            nexusMatrix,
                            connector,
                            targetNexusLayerIndex
                    );
                    // adjust nexus size
                    double amountShrunk = resizeNexusToDefault( nexus );
                    /*
                     * shift node so that it is centered relative to its parent
                     */
                    nexus.getView().setLayoutX(
                            nexus.getView().getLayoutX()
                            + ( amountShrunk / 2 )
                    );
                    /*
                     * reposition subtrees of nexus so that they are in the
                     * correct relative positions
                     */
                    shiftNexusChildrenOnDetach( nexus );
                }
                //undraw old counter arg structures
                subCounterConnectionNode
                        .getParent()
                        .removeChild(
                                subCounterConnectionNode
                        );
                subCounterConnectionNode.setParent( null );
                eraseTree( subCounterConnectionNode );
            }
            // remove any duplicate values
            Set<CounterArgumentModel> disposal
                    = new LinkedHashSet<>( consolidatedCounterArguments );
            consolidatedCounterArguments.clear();
            consolidatedCounterArguments.addAll( disposal );

            for ( ArgumentModel argument : argumentList )
            {
                // temp reference to counter arg list for this conclusion
                List<CounterArgumentModel> currentCounterArguments
                        = argument.getConclusion().getCounterArgumentList();
                //copy consolidated list to current conclusion's counter list
                // clear this list. Will be populated later with consolidated list
                currentCounterArguments.clear();
                currentCounterArguments.addAll( consolidatedCounterArguments );
                //make sure that counter arguments have references to their
                //parent models
                for ( CounterArgumentModel counterArg : consolidatedCounterArguments )
                {
                    counterArg.addToParentModelList( argument.getConclusion() );
                }
            }
            collisionAdjustment();
        }
    }

    public void createMultiArgChain( String mergeTreeID,
            ChainPaneController chainControl ) throws IOException
    {
        int numPremises = 2;
        ArgumentViewTree mergedTree = canvasControl.getArgTree( mergeTreeID );
        ConclusionNode mergeTreeRoot = mergedTree.getRoot();
        mergedTree.deleteCommentPanes();
        if ( !( mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController ) )
        {
            ChainNode chainNode
                    = ( ChainNode ) searchForNode(
                            root,
                            chainControl.getMainPane()
                    );
            ArgumentNode targetMatrix = findNextNexus( chainNode );
            List<ArgumentNode> targetNexusMatrixLayer
                    = findMatrixLayer( targetMatrix, nexusMatrix );
            List<ArgumentNode> targetPaneMatrixLayer
                    = findMatrixLayer( chainNode, paneMatrix );

            ChainNode multiChain
                    = createMultiArgChainView(
                            mergeTreeRoot.getControl(),
                            chainControl
                    );

            chainNode.getParent().addAsChild( multiChain );
            multiChain.setParent( chainNode.getParent() );
            multiChain.getParent().removeChild( chainNode );

            ArgumentNode connector
                    = createConclusionConnector( multiChain.getView() );
            multiChain.addAsChild( connector );
            connector.setParent( multiChain );
            canvas.getChildren().add( connector.getView() );

            ArgumentNode label
                    = createMultiArgLabel( multiChain.getView() );
            multiChain.addAsChild( label );
            label.setParent( multiChain );
            canvas.getChildren().add( label.getView() );

            ArgumentNode nexus = createNexus( numPremises, connector.getView() );
            connector.addAsChild( nexus );
            nexus.setParent( connector );
            canvas.getChildren().add( nexus.getView() );

            ArgumentNode premiseConnect
                    = createMultiArgPremiseConnection( nexus.getView(), 0 );
            nexus.addAsChild( premiseConnect );
            premiseConnect.setParent( nexus );
            canvas.getChildren().add( premiseConnect.getView() );

            ArgumentNode multiArgSub = createMultiArgSubView(
                    chainNode.getControl().getConclusionArgumentModel(),
                    premiseConnect.getView(),
                    chainNode.getControl().getCertaintyController(),
                    0
            );

            replaceConnectorWithMultiArgConnector( chainNode );

            premiseConnect.addAsChild( multiArgSub );
            multiArgSub.setParent( premiseConnect );
            canvas.getChildren().add( multiArgSub.getView() );
            translateNode( chainNode,
                    multiArgSub.getView().getBoundsInParent().getMinX()
                    - chainNode.getView().getBoundsInParent().getMinX()
                    - ( ( PREMISE_WIDTH - 40 ) / 2 ),
                    multiArgSub.getView().getBoundsInParent().getMinY()
                    - chainNode.getView().getBoundsInParent().getMinY()
                    - ( PREMISE_HEIGHT - 40 )
            );
            ListIterator<ArgumentNode> mainConChildrenIT
                    = chainNode.getChildren().listIterator();
            while ( mainConChildrenIT.hasNext() )
            {
                ArgumentNode child = mainConChildrenIT.next();
                multiArgSub.addAsChild( child );
                child.setParent( multiArgSub );
                mainConChildrenIT.remove();
            }
            for ( ArgumentNode node : multiArgSub.getChildren() )
            {
                if ( node instanceof ArgumentCertaintyNode )
                {
                    node.getView().setLayoutX( node.getView().getLayoutX() - 85 );
                }
                if ( node instanceof CQConnectionNode
                        || node instanceof ArgumentSchemeLabel )
                {
                    translateNode( node, 0, 205 );
                }
            }
            replaceInPaneMatrix( chainNode, multiArgSub );

            ArgumentNode premiseConnectB
                    = createMultiArgPremiseConnection( nexus.getView(), 1 );
            nexus.addAsChild( premiseConnectB );
            premiseConnectB.setParent( nexus );
            canvas.getChildren().add( premiseConnectB.getView() );

            ArgumentNode multiArgSubB = createMultiArgSubView(
                    mergeTreeRoot.getControl().getConclusionArgumentModel(),
                    premiseConnectB.getView(),
                    mergeTreeRoot.getControl().getCertaintyController(),
                    1
            );

            replaceConnectorWithMultiArgConnector( mergedTree.getRoot() );

            premiseConnectB.addAsChild( multiArgSubB );
            multiArgSubB.setParent( premiseConnectB );
            canvas.getChildren().add( multiArgSubB.getView() );
            mergedTree.translateTree( multiArgSubB.getView().getBoundsInParent().getMinX()
                    - ( ( PREMISE_WIDTH - 40 ) / 2 ),
                    multiArgSubB.getView().getBoundsInParent().getMinY()
                    - ( PREMISE_HEIGHT - 40 )
            );
            ListIterator<ArgumentNode> mergeConChildrenIT
                    = mergedTree.getRoot().getChildren().listIterator();
            while ( mergeConChildrenIT.hasNext() )
            {
                ArgumentNode child = mergeConChildrenIT.next();
                multiArgSubB.addAsChild( child );
                child.setParent( multiArgSubB );
                mergeConChildrenIT.remove();
            }
            for ( ArgumentNode node : multiArgSubB.getChildren() )
            {
                if ( node instanceof ArgumentCertaintyNode )
                {
                    node.getView().setLayoutX( node.getView().getLayoutX() - 85 );
                }
                if ( node instanceof CQConnectionNode
                        || node instanceof ArgumentSchemeLabel )
                {
                    translateNode( node, 0, 205 );
                }
            }
            mergedTree.replaceInPaneMatrix( mergedTree.getRoot(), multiArgSubB );
            changeArgTree( root );

            canvas.getChildren().add( multiChain.getView() );
            canvas.getChildren().remove( chainNode.getView() );

            canvasControl.removeArgumentTree( mergeTreeID );
            canvas.getChildren().remove( mergeTreeRoot.getView() );

            mergeMatrices(
                    targetPaneMatrixLayer,
                    paneMatrix,
                    mergedTree.paneMatrix
            );
            mergeMatrices(
                    targetNexusMatrixLayer,
                    nexusMatrix,
                    mergedTree.nexusMatrix
            );
            updateNexusMatrixShiftForward( nexus, paneMatrix );
            updateNexusMatrixShiftForward( nexus, nexusMatrix );
            targetPaneMatrixLayer.add( multiChain );
            targetNexusMatrixLayer.add( nexus );

            mergeCounterArguments(
                    multiChain,
                    multiArgSub,
                    multiArgSubB
            );

            collisionAdjustment();
        }
    }

    // Collision detection and matrix operations
    //--------------------------------------------------------------------------
    /**
     * method checks the pane and nexus nodes of the argument tree. If there is
     * overlap between pane nodes on the same level, this method recurses up the
     * tree to find their shared link and grows the appropriate connector to
     * remove the overlap. It then shifts tree elements in order to their new
     * positions. If a change is made, this method is called again because any
     * changes might cause collisions with other panes(like bubble-sort).
     */
    private void collisionAdjustment()
    {
        boolean paneMatrixAdjusted = paneMatrixAdjustment();
        /*
         * recheck tree to see if further adjustments need to be made as a
         * result of other changes
         */
        if ( paneMatrixAdjusted )
        {
            collisionAdjustment();
        } else
        {
            nexusMatrixAdjustment();
        }
    }

    /**
     * Method checks the pane nodes of the argument tree. If there is overlap
     * between pane nodes on the same level, the youngest common ancestor of the
     * colliding nodes is found and the tree structure is adjusted to create the
     * necessary space
     *
     * @return boolean True if any adjustments are made
     */
    private boolean paneMatrixAdjustment()
    {
        boolean adjustmentMade = false;
        for ( List<ArgumentNode> paneLayer : paneMatrix )
        {
            for ( ArgumentNode targetPane : paneLayer )
            {
                /*
                 * compare the positions of each pane in a layer to every other
                 * pane in the layer.
                 */
                for ( ArgumentNode comparePane : paneLayer )
                {
                    /*
                     * avoid comparingthe dimensions of a pane to itself
                     */
                    if ( !targetPane.equals( comparePane ) )
                    {
                        double overlap = detectPaneOverlap( targetPane, comparePane );
                        /*
                         * if there is not enought space between the panes, grow
                         * their shared ancestor (nexus or connector)
                         */
                        if ( overlap > 0 )
                        {
                            // find linking Node
                            ArgumentNode linkingNode
                                    = findLinkingNode( targetPane, comparePane );
                            if ( linkingNode instanceof PremiseNexusNode )
                            {
                                premiseNexusCollision(
                                        ( PremiseNexusNode ) linkingNode,
                                        overlap
                                );
                            } else
                            {
                                otherCollision(
                                        linkingNode,
                                        targetPane,
                                        comparePane,
                                        overlap );
                            }
                            // note that an adjustment was made
                            adjustmentMade = true;
                        }
                    }
                }
            }
        }
        return adjustmentMade;
    }

    /**
     * Method checks the nexus nodes of the argument tree. If there is overlap
     * between pane nodes on the same level, the youngest common ancestor of the
     * colliding nodes is found and the tree structure is adjusted to create the
     * necessary space
     *
     * @return boolean True if any adjustments are made
     */
    private void nexusMatrixAdjustment()
    {
        boolean adjustmentMade = false;
        for ( List<ArgumentNode> nexusLayer : nexusMatrix )
        {
            /*
             * for each necus in the layer, check the other nexuses in the same
             * layer
             */
            for ( ArgumentNode nexus : nexusLayer )
            {
                for ( ArgumentNode compareNexus : nexusLayer )
                {
                    /*
                     * avoid comparingthe dimensions of a pane to itself
                     */
                    if ( !nexus.equals( compareNexus ) )
                    {
                        // get the overlap between the nodes
                        double overlap
                                = detectNexusOverlap(
                                        nexus, compareNexus
                                );
                        if ( overlap > 0 )
                        {
                            // find linking Node
                            ArgumentNode linkingNode
                                    = findLinkingNode( nexus, compareNexus );
                            if ( linkingNode instanceof PremiseNexusNode )
                            {
                                premiseNexusCollision(
                                        ( PremiseNexusNode ) linkingNode,
                                        overlap
                                );
                            } else
                            {
                                otherCollision(
                                        linkingNode,
                                        nexus,
                                        compareNexus,
                                        overlap );
                            }
                            // note that an adjustment was made
                            adjustmentMade = true;
                        }
                    }
                }
            }
        }
        if ( adjustmentMade )
        {
            collisionAdjustment();
        }
    }

    /**
     * helper method calculates how much space needs to be made between two
     * argument panes on the same layer. A minimum of PREMISE_WIDTH is required
     * between nexuses
     *
     * @param current ArgumentNode
     * @param compare ArgumentNode
     *
     * @return double
     */
    private double detectPaneOverlap(
            ArgumentNode targetPane,
            ArgumentNode comparePane )
    {
        double targetMinX
                = targetPane
                        .getView()
                        .getBoundsInParent()
                        .getMinX();
        double targetMaxX
                = targetPane
                        .getView()
                        .getBoundsInParent()
                        .getMaxX();

        double compareMinX
                = comparePane
                        .getView()
                        .getBoundsInParent()
                        .getMinX();
        double compareMaxX
                = comparePane
                        .getView()
                        .getBoundsInParent()
                        .getMaxX();

        if ( ( compareMinX < ( targetMaxX + PADDING )
                && compareMinX > ( targetMinX - PADDING ) )
                || ( compareMaxX > ( targetMinX - PADDING )
                && compareMaxX < ( targetMinX + PADDING ) ) )
        {
            return Math.min(
                    Math.abs( compareMaxX - ( targetMinX + PADDING ) ),
                    Math.abs( compareMinX - ( targetMaxX + PADDING ) )
            );
        }
        return -1;
    }

    /**
     * helper method calculates how much space needs to be made between two
     * nexuses.
     *
     * @param targetNexus  ArgumentNode
     * @param compareNexus ArgumentNode
     *
     * @return
     */
    private double detectNexusOverlap(
            ArgumentNode targetNexus,
            ArgumentNode compareNexus )
    {
        double targetMinX
                = targetNexus
                        .getView()
                        .getBoundsInParent()
                        .getMinX();
        double targetMaxX
                = targetNexus
                        .getView()
                        .getBoundsInParent()
                        .getMaxX();

        double compareMinX
                = compareNexus
                        .getView()
                        .getBoundsInParent()
                        .getMinX();
        double compareMaxX
                = compareNexus
                        .getView()
                        .getBoundsInParent()
                        .getMaxX();

        if ( ( compareMinX < ( targetMaxX + PADDING + PREMISE_WIDTH )
                && compareMinX > ( targetMinX - PADDING + PREMISE_WIDTH ) )
                || ( compareMaxX > ( targetMinX - PADDING + PREMISE_WIDTH )
                && compareMaxX < ( targetMaxX + PADDING + PREMISE_WIDTH ) ) )
        {
            return Math.min(
                    Math.abs(
                            compareMaxX - ( targetMinX + PADDING + PREMISE_WIDTH )
                    ),
                    Math.abs(
                            compareMinX - ( targetMaxX + PADDING + PREMISE_WIDTH )
                    )
            );
        }
        return -1;
    }

    /**
     * Re-routes collision adjustment to correct method depending on the type of
     * nodes colliding
     *
     * @param linkingNode  ArgumentNode common ancestor node
     * @param nexus        ArgumentNode
     * @param compareNexus ArgumentNode
     * @param overlap      double overlap between argument nodes
     */
    private void otherCollision(
            ArgumentNode linkingNode,
            ArgumentNode nexus,
            ArgumentNode compareNexus,
            double overlap )
    {
        for ( ArgumentNode child : linkingNode.getChildren() )
        {
            if ( child instanceof CounterArgumentConnectionNode
                    && ( containsNode( child, nexus )
                    || containsNode( child, compareNexus ) ) )
            {
                counterArgumentConnectionCollision(
                        ( CounterArgumentConnectionNode ) child,
                        overlap
                );
            } else if ( child instanceof CQConnectionNode
                    && ( containsNode( child, nexus )
                    || containsNode( child, compareNexus ) ) )
            {
                cqConnectionCollision(
                        ( CQConnectionNode ) child,
                        overlap
                );
            }
        }

    }

    /**
     * Grows a CQ connector to solve a collision involving a critical question
     * structure
     *
     * @param cqConnector ArgumentNode the connector being grown
     * @param overlap     double overlap of collision
     */
    private void cqConnectionCollision(
            CQConnectionNode cqConnector,
            double overlap
    )
    {
        /*
         * grow and move the CQ connection
         */
        cqConnector.addLength( ( int ) overlap );
        translateNode( cqConnector, -overlap, 0 );
    }

    /**
     * Grows a counter argument connector to solve a collision involving a
     * counter argument structure
     *
     * @param counterArgConnector ArgumentNode the connector being grown
     * @param overlap             double overlap of collision
     */
    private void counterArgumentConnectionCollision(
            CounterArgumentConnectionNode counterArgConnector,
            double overlap )
    {
        /*
         * grow the counter argument connection
         */
        counterArgConnector.addLength( ( int ) overlap );
        /*
         * shift the counter argument structure to align with new length
         */
        for ( ArgumentNode child : counterArgConnector.getChildren() )
        {
            translateNode( child, overlap, 0 );
        }
    }

    /**
     * Grows a ArgumentNode nexus to solve a collision not involving critical
     * questions or counter arguments
     *
     * @param sharedNexus ArgumentNode common ancestor
     * @param overlap     double overlap of collision
     */
    private void premiseNexusCollision(
            PremiseNexusNode sharedNexus,
            double overlap )
    {
        /*
         * grow and shift the ancestor nexus to accomidate the growth
         */
        int numChildren = sharedNexus.getChildren().size();
        sharedNexus.growWidth( overlap * ( numChildren - 1 ) );
        sharedNexus.getView().setLayoutX(
                sharedNexus.getView().getLayoutX()
                - ( ( overlap * ( numChildren - 1 ) ) / 2 )
        );
        /*
         * shift the left and right sub-trees of the ancestor nexus
         */
        shiftRightSidePremises( sharedNexus, overlap );
        shiftLeftSidePremises( sharedNexus, overlap );
    }

    /**
     * shifts the left children of a nexus
     *
     * @param nexus
     * @param growth
     */
    private void shiftLeftSidePremises( PremiseNexusNode nexus, double growth )
    {
        int numChildren = nexus.getChildren().size();
        int sideCounter = 0;
        for ( int i = 0; i < numChildren / 2; i++ )
        {
            translateNode(
                    nexus.getChildren().get( i ),
                    -( ( growth * ( numChildren - 1 ) ) / 2 )
                    + ( growth * sideCounter ),
                    0
            );
            sideCounter++;
        }
    }

    /**
     * shifts the right side children of a nexus
     *
     * @param nexus
     * @param growth
     */
    private void shiftRightSidePremises( PremiseNexusNode nexus, double growth )
    {
        int numChildren = nexus.getChildren().size();
        int sideCounter = 0;
        for ( int i = numChildren; i > numChildren / 2; i-- )
        {
            translateNode(
                    nexus.getChildren().get( i - 1 ),
                    ( ( growth * ( numChildren - 1 ) ) / 2 )
                    - ( growth * sideCounter ),
                    0
            );
            sideCounter++;
        }
    }

    /**
     * Method to find the common ancestor of 2 ArgumentNodes
     *
     * @param a ArgumentNode
     * @param b ArgumentNode
     *
     * @return ArgumentNode common ancestor
     */
    private ArgumentNode findLinkingNode( ArgumentNode a, ArgumentNode b )
    {
        List<ArgumentNode> aAncestryList = new ArrayList<>();
        ArgumentNode youngestLinkingNode = null;
        while ( a != null )
        {
            aAncestryList.add( a );
            a = a.getParent();
        }
        while ( youngestLinkingNode == null && b != null )
        {
            if ( aAncestryList.contains( b ) )
            {
                youngestLinkingNode = b;
            }
            b = b.getParent();
        }

        return youngestLinkingNode;
    }

    private void updateNexusMatrix(
            ArgumentNode parentPane,
            ArgumentNode counterIcon,
            ArgumentNode counterPane )
    {
        ListIterator<List<ArgumentNode>> matrixIt = paneMatrix.listIterator( 0 );
        List<ArgumentNode> targetLayer = null;
        while ( targetLayer == null && matrixIt.hasNext() )
        {
            List<ArgumentNode> inspectedLayer = matrixIt.next();
            for ( ArgumentNode pane : inspectedLayer )
            {
                if ( pane.equals( parentPane ) )
                {
                    targetLayer = inspectedLayer;
                }
            }
        }

        targetLayer.add( counterIcon );

        if ( !matrixIt.hasNext() )
        {
            List<ArgumentNode> newLayer = new ArrayList<>();
            matrixIt.add( newLayer );
            matrixIt.previous();
        }
        targetLayer = matrixIt.next();
        targetLayer.add( counterPane );
    }

    private void updateAllCollisionMatricesOnDetach(
            ArgumentViewTree newArgTree
    )
    {
        updateMatrixOnDetach(
                newArgTree,
                paneMatrix,
                newArgTree.getPaneMatrix()
        );
        updateMatrixOnDetach(
                newArgTree,
                nexusMatrix,
                newArgTree.getNexusMatrix()
        );
    }

    private void removeSubTreeFromMatrices( ArgumentNode target )
    {
        removeSubTreeFromMatrix( target, paneMatrix );
        removeSubTreeFromMatrix( target, nexusMatrix );
    }

    private void removeSubTreeFromMatrix(
            ArgumentNode target,
            List<List<ArgumentNode>> matrix
    )
    {
        ListIterator<List<ArgumentNode>> layerIT
                = matrix.listIterator();
        while ( layerIT.hasNext() )
        {
            List<ArgumentNode> currentLayer = layerIT.next();
            ListIterator<ArgumentNode> nodeIT
                    = currentLayer.listIterator();
            while ( nodeIT.hasNext() )
            {
                ArgumentNode currentNode = nodeIT.next();
                if ( containsNode( target, currentNode ) )
                {
                    nodeIT.remove();
                    if ( currentLayer.isEmpty() )
                    {
                        layerIT.remove();
                    }
                }
            }
        }
    }

    private void printMatrix( List<List<ArgumentNode>> matrix )
    {
        for ( int i = 0; i < matrix.size(); i++ )
        {
            System.out.print( "Layer " + i + ": " );
            for ( int j = 0; j < matrix.get( i ).size(); j++ )
            {
                System.out.print( ":" + matrix.get( i ).get( j ) + ": " );
            }
            System.out.println( "" );
        }
    }

    private List<ArgumentNode> findMatrixLayer(
            ArgumentNode target,
            List<List<ArgumentNode>> matrix
    )
    {
        List<ArgumentNode> targetLayer = null;
        for ( int i = 0; targetLayer == null && i < matrix.size(); i++ )
        {
            for ( int j = 0;
                    targetLayer == null && j < matrix.get( i ).size();
                    j++ )
            {
                if ( matrix.get( i ).get( j ).equals( target ) )
                {
                    targetLayer = matrix.get( i );
                }
            }
        }
        if ( targetLayer != null )
        {
            return targetLayer;
        } else
        {
            targetLayer = new ArrayList<>();
            matrix.add( targetLayer );
            return targetLayer;
        }
    }

    private ArgumentNode findNextNexus( ArgumentNode node )
    {
        Queue<ArgumentNode> queue = new LinkedList<>();
        ArgumentNode resultNode = null;
        queue.add( node );
        while ( resultNode == null && !queue.isEmpty() )
        {
            ArgumentNode currentNode = queue.remove();
            if ( currentNode instanceof PremiseNexusNode )
            {
                resultNode = currentNode;
            } else
            {
                queue.addAll( currentNode.getChildren() );
            }
        }
        return resultNode;
    }

    @Override
    public String toString()
    {
        StringBuilder s = new StringBuilder();

        List<ArgumentNode> children = this.root.getChildren();

        for ( ArgumentNode am : children )
        {
            s.append( am ).append( "\n" );
        }
        return s.toString();
    }
}
